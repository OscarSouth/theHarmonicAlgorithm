-- test_traversal.tidal
-- Diagnostic tests for the unified generation interface
--
-- Run in GHCi: `:load live/test_traversal.tidal`
-- All functions from Harmonic.Lib are available via BootTidal.hs
--
-- UNIFIED GENERATION INTERFACE:
-- Three main functions with identical signatures:
--   gen start len "*" 0.5 ctx    :: IO Progression (no output)
--   gen' start len "*" 0.5 ctx   :: IO Progression (compact musical summary)
--   gen'' start len "*" 0.5 ctx  :: IO Progression (verbose traces)
--
-- Advanced use: extract diagnostics from tuples
--   generate' start len "*" 0.5 ctx  :: IO (Progression, GenerationDiagnostics)
--
-- PIPELINE OVERVIEW:
-- The generation algorithm follows a six-stage pipeline per step:
--   [1] PRIOR STATE: Root + cadence before selection
--   [2] CANDIDATE POOL: Graph + fallback ranked by dissonance
--   [3] SELECTED FROM DB: Movement + zero-form intervals from Neo4j
--   [4] ADVANCE: Root motion computation (prior PC + movement = posterior PC)
--   [5] POSTERIOR STATE: New root + cadence after advance
--   [6] RENDER: Transpose intervals by root + name chord
--
-- ZERO-FORM INVARIANT:
-- All cadence intervals are stored relative ([P 0, ...]), enabling transposition:
--   posterior chord = posteriorRootPC + cadenceIntervals
-- This guarantees DB name == computed name (verified each step)

-------------------------------------------------------------------------------
-- TEST 1: Length Verification (off-by-one fix)
-------------------------------------------------------------------------------

putStrLn "\n=== TEST 1: Length Verification ==="
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext
forM_ [4, 8, 12, 16] $ \len ->
  gen start len "*" 0.5 ctx >>= \prog ->
    let actual = progLength prog
    in putStrLn $ "  Requested: " ++ show len ++ " -> Actual: " ++ show actual
                  ++ " [" ++ (if len == actual then "PASS" else "FAIL") ++ "]"

-------------------------------------------------------------------------------
-- TEST 2: Starting Chord Preservation
-------------------------------------------------------------------------------

putStrLn "\n=== TEST 2: Starting Chord Preservation ==="
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext
gen start 4 "*" 0.5 ctx >>= \prog ->
  let cs1 = getCadenceState prog 1
  in do
    putStrLn $ "  Initial: " ++ show start
    putStrLn $ "  First chord: " ++ show cs1
    putStrLn $ "  Match: " ++ show (cs1 == Just start)

-------------------------------------------------------------------------------
-- TEST 3: CadenceState Round-Trip Conversion
-------------------------------------------------------------------------------

putStrLn "\n=== TEST 3: CadenceState Round-Trip ==="
let testCases =
      [ (0, "C", [0,4,7], "C major")
      , (7, "G", [0,4,7], "G major")
      , (0, "A", [0,3,7], "A minor")
      ]
forM_ testCases $ \(mvmt, note, qual, desc) ->
  let cs = initCadenceState mvmt note qual FlatSpelling
      chord = fromCadenceState cs
  in putStrLn $ "  " ++ desc ++ ": ✓"

-------------------------------------------------------------------------------
-- TEST 4: Standard Diagnostics Output (genStandard)
-------------------------------------------------------------------------------

putStrLn "\n=== TEST 4: Standard Diagnostics (genStandard) ==="
putStrLn "  Shows per-step candidate pools, selections, rendered chords:"
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext
genStandard start 4 "*" 0.5 ctx

-------------------------------------------------------------------------------
-- TEST 5: Entropy Effect on Gamma Sampling
-------------------------------------------------------------------------------

putStrLn "\n=== TEST 5: Entropy Effect on Selection ==="
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext
forM_ [0.0, 0.5, 1.0] $ \entropy ->
  generate' start 8 "*" entropy ctx >>= \(_, diag) ->
    let indices = map sdGammaIndex (gdSteps diag)
        avgIdx = fromIntegral (sum indices) / fromIntegral (length indices) :: Double
    in putStrLn $ "  Entropy " ++ show entropy ++ ": avg index = " ++ show (round (avgIdx * 100) :: Int) / 100

-------------------------------------------------------------------------------
-- TEST 6: Diverse Movement Traversal
-------------------------------------------------------------------------------

putStrLn "\n=== TEST 6: Movement Diversity in 12-Chord Generation ==="
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext
generate' start 12 "*" 0.5 ctx >>= \(prog, diag) ->
  let movements = map sdSelectedDbMovement (gdSteps diag)
      unique xs = foldr (\x acc -> if x `elem` acc then acc else x:acc) [] xs
      uniqueCount = length $ unique movements
  in do
    putStrLn $ "  Total steps: " ++ show (length movements)
    putStrLn $ "  Unique movements: " ++ show uniqueCount
    putStrLn $ "  Diversity: " ++ (if uniqueCount > 4 then "GOOD" else "LIMITED")

-------------------------------------------------------------------------------
-- TEST 7: Graph vs Fallback Selection Ratio
-------------------------------------------------------------------------------

putStrLn "\n=== TEST 7: Graph vs Fallback Selection Ratio ==="
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext
generate' start 16 "*" 0.5 ctx >>= \(_, diag) ->
  let steps = gdSteps diag
      graphCount = length $ filter ((== "graph") . sdSelectedFrom) steps
      fallbackCount = length $ filter ((== "fallback") . sdSelectedFrom) steps
      totalSteps = length steps
      graphRatio = 100 * graphCount `div` max 1 totalSteps
  in do
    putStrLn $ "  Steps: " ++ show totalSteps
    putStrLn $ "  Graph: " ++ show graphCount ++ " (" ++ show graphRatio ++ "%)"
    putStrLn $ "  Fallback: " ++ show fallbackCount ++ " (" ++ show (100 - graphRatio) ++ "%)"

-------------------------------------------------------------------------------
-- TEST 8: Verbose Diagnostics with Transform Traces
-------------------------------------------------------------------------------

putStrLn "\n=== TEST 8: Verbose Diagnostics (gen'') ==="
putStrLn "  Shows standard diagnostics plus transform and advance traces:"
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext
gen'' start 4 "*" 0.8 ctx

-------------------------------------------------------------------------------
-- SUMMARY
-------------------------------------------------------------------------------

putStrLn "\n═══════════════════════════════════════════════════════════════════"
putStrLn "Test Suite Complete"
putStrLn "═══════════════════════════════════════════════════════════════════"
putStrLn ""
putStrLn "Tests Run:"
putStrLn "  1. Length verification (gen)"
putStrLn "  2. Starting chord preservation (gen)"
putStrLn "  3. CadenceState round-trip (gen)"
putStrLn "  4. Standard diagnostics (genStandard)"
putStrLn "  5. Entropy effect (generate')"
putStrLn "  6. Movement diversity (generate')"
putStrLn "  7. Graph/fallback ratio (generate')"
putStrLn "  8. Verbose diagnostics (gen'')"
putStrLn ""

