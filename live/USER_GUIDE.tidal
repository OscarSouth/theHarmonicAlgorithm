-- ═══════════════════════════════════════════════════════════════════════════
-- THE HARMONIC ALGORITHM - USER GUIDE
-- ═══════════════════════════════════════════════════════════════════════════
-- Playable documentation for TidalCycles integration
-- Execute code blocks from top to bottom for a guided tour
--
-- Generated by 'The Harmonic Algorithm' -> https://github.com/OscarSouth/theHarmonicAlgorithm
--
-- Prerequisites:
--   1. Neo4j running (docker compose up -d neo4j)
--   2. BootTidal.hs loaded with Harmonic.Lib imports
--   3. MIDI/SuperDirt configured for d01-d16 outputs


-- ═══════════════════════════════════════════════════════════════════════════
-- SECTION 1: QUICK START
-- ═══════════════════════════════════════════════════════════════════════════
-- Goal: Get sound immediately

-- Step 1: Generate a 4-chord progression (requires Neo4j running)
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext
prog <- gen start 4 "*" 0.5 ctx

-- Step 2: Play it (flow voicing = smoothest voice leading)
d1 $ note (harmony prog "<0 1 2 3>") # s "superpiano"

-- Step 3: Stop playback
hush


-- ═══════════════════════════════════════════════════════════════════════════
-- SECTION 2: CORE CONCEPTS
-- ═══════════════════════════════════════════════════════════════════════════
-- Goal: Understand the building blocks

-- ───────────────────────────────────────────────────────────────────────────
-- 2.1 CadenceState - Starting Point
-- ───────────────────────────────────────────────────────────────────────────
-- CadenceState defines WHERE you start harmonically
-- Signature: initCadenceState :: Int -> String -> [Int] -> EnharmonicSpelling -> CadenceState

let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    -- 0 = movement (semitones from implicit prior, usually 0 for first chord)
    -- "C" = root note name
    -- [0,4,7] = major triad intervals (pitch classes relative to root)
    -- FlatSpelling = prefer flats over sharps in output

-- Other common starting qualities:
let minor = initCadenceState 0 "A" [0,3,7] FlatSpelling      -- A minor
let dim   = initCadenceState 0 "B" [0,3,6] SharpSpelling     -- B diminished
let sus4  = initCadenceState 0 "D" [0,5,7] FlatSpelling      -- D sus4
let aug   = initCadenceState 0 "C" [0,4,8] FlatSpelling      -- C augmented
let dom7  = initCadenceState 0 "G" [0,4,7,10] FlatSpelling   -- G7 (dominant)


-- ───────────────────────────────────────────────────────────────────────────
-- 2.2 HarmonicContext - Constraints (R in R→E→T)
-- ───────────────────────────────────────────────────────────────────────────
-- HarmonicContext filters what chords can appear during generation
-- Three independent filters: overtones, key, roots
-- Signature: hContext :: String -> String -> String -> HarmonicContext

let ctx = defaultContext  -- No filtering: "*" "*" "*"

-- OVERTONE FILTERING (pitch palette constraint)
-- Limits generation to pitches in the overtone series of specified notes
let bassCtx = hContext "E A D G" "*" "*"  -- Bass tuning overtones only
let guitarCtx = hContext "E A D G B E" "*" "*"  -- Standard guitar tuning

-- KEY FILTERING (tonality constraint)
-- Limits generation to pitches in a specific key/scale
let gMajor = hContext "*" "1#" "*"    -- G major (1 sharp)
let dMajor = hContext "*" "##" "*"    -- D major (2 sharps)
let cMajor = hContext "*" "C" "*"     -- C major (natural key)
let fMajor = hContext "*" "1b" "*"    -- F major (1 flat)
let bbMajor = hContext "*" "2b" "*"   -- Bb major (2 flats)

-- ROOT FILTERING (bass note constraint)
-- Limits generation to specific root notes
let cAndG = hContext "*" "*" "C G"           -- Only C and G roots
let fifthsOnly = hContext "*" "*" "C G D A"  -- Circle of fifths subset

-- COMBINED FILTERING
-- Apply multiple constraints simultaneously
let jazzCtx = hContext "*" "##" "D F# A"        -- D major, specific roots
let modalCtx = hContext "D E F G A B C" "*" "*" -- Dorian mode pitches

-- KEY FILTERING BEHAVIOR (STRICT CONSTRAINT)
-- The 'key' parameter STRICTLY filters ALL pitches in generated chords.
-- This includes:
--   - Root notes
--   - Chord tones (3rds, 5ths, 7ths)
--   - Upper structures (9ths, 11ths, 13ths, alterations)
-- NO chord will contain ANY pitch outside the specified key.
--
-- Example: D major key filter
let dmajorCtx = hContext "*" "2#" "*"
-- D major scale: D E F# G A B C# (pitch classes: 2,4,6,7,9,11,1)
-- Accepted chords: D maj, Em, F#m, G maj, A maj, Bm, C# dim
-- Rejected chords: E maj (contains G#), Bb maj (contains Bb), C maj (contains C natural)
--
-- This applies to BOTH:
--   1. Graph candidates (historical transitions from Neo4j database)
--   2. Fallback candidates (algorithmic generation when no graph match)
--
-- Use this for live performance with other musicians to ensure harmonic compatibility.


-- ───────────────────────────────────────────────────────────────────────────
-- 2.3 Generation - Three Verbosity Levels
-- ───────────────────────────────────────────────────────────────────────────
-- All three have IDENTICAL signatures, different console output
-- Signature: gen['//''] :: CadenceState -> Int -> String -> Double -> HarmonicContext -> IO Progression

-- SILENT: No console output (for performance/production)
prog1 <- gen start 8 "*" 0.5 ctx

-- STANDARD: Per-step diagnostics (for exploration)
-- Shows: candidate pools, selections, rendered chords
prog2 <- gen' start 8 "*" 0.5 ctx

-- VERBOSE: Full traces (for debugging)
-- Shows: standard output + transform/advance traces
prog3 <- gen'' start 8 "*" 0.5 ctx

-- Parameters explained:
-- start = CadenceState (where to begin)
-- 8 = number of chords to generate
-- "*" = composer blend (see Section 2.5 for weighting syntax)
-- 0.5 = entropy [0.0 = conservative/greedy, 2.0+ = exploratory/random]
-- ctx = HarmonicContext (filter constraints)


-- ───────────────────────────────────────────────────────────────────────────
-- 2.4 Pitch Removal with '-' Operator
-- ───────────────────────────────────────────────────────────────────────────
-- All three harmonic context parameters (overtones, key, roots) support
-- pitch removal using the '-' prefix operator.
--
-- ORDER OF OPERATIONS:
-- 1. Union all positive tokens (without '-')
-- 2. Union all negative tokens (with '-', prefix stripped)
-- 3. Subtract negative from positive

-- ─── OVERTONES PARAMETER ───────────────────────────────────────────────────
-- Overtones: 'G' = G overtones [7,11,2,6], 'G'' = G pitch [7]

let ctx1 = hContext "C E -E'" "*" "*"
-- C overtones [0,4,7,10] ∪ E overtones [4,8,11,1] \ {E pitch 4}
-- Result: [0,1,7,8,10,11]

let ctx2 = hContext "* -G" "*" "*"
-- All pitches [0..11] \ G overtones [7,11,2,6]
-- Result: [0,1,3,4,5,8,9,10]

let ctx3 = hContext "* -G'" "*" "*"
-- All pitches [0..11] \ {G pitch 7}
-- Result: [0,1,2,3,4,5,6,8,9,10,11]

-- ─── KEY PARAMETER ─────────────────────────────────────────────────────────
-- Key: 'G' = G major scale [0,2,4,6,7,9,11], 'G'' = G pitch [7]

let ctx4 = hContext "*" "1b -G'" "*"
-- F major [0,2,4,5,7,9,10] \ {G pitch 7}
-- Result: [0,2,4,5,9,10]

let ctx5 = hContext "*" "1b 2# -G" "*"
-- (F major [0,2,4,5,7,9,10] ∪ D major [1,2,4,6,7,9,11]) \ G major [0,2,4,6,7,9,11]
-- Result: [1,5,10]

let ctx6 = hContext "*" "* -C' -F#'" "*"
-- All pitches [0..11] \ {C=0, F#=6}
-- Result: [1,2,3,4,5,7,8,9,10,11]

-- ─── ROOTS PARAMETER ───────────────────────────────────────────────────────
-- Roots: INVERTED prime notation: 'G' = G pitch [7], 'G'' = G major scale

let ctx7 = hContext "*" "*" "C G -G"
-- {C=0, G=7} \ {G=7}
-- Result: [0]

let ctx8 = hContext "*" "*" "* -E -A -D -G"
-- All pitches [0..11] \ {E=4, A=9, D=2, G=7}
-- Result: [0,1,3,5,6,8,10,11] (all except bass tuning notes)

let ctx9 = hContext "*" "*" "2# C F"
-- D major [1,2,4,6,7,9,11] ∪ C [0] ∪ F [5] (token-by-token)
-- Result: [0,1,2,4,5,6,7,9,11]

let ctx10 = hContext "*" "*" "G'"
-- G major scale [0,2,4,6,7,9,11] (INVERTED: prime = scale in roots)
-- Result: [0,2,4,6,7,9,11]

let ctx11 = hContext "*" "*" "G' -G"
-- G major scale [0,2,4,6,7,9,11] \ {G pitch 7}
-- Result: [0,2,4,6,9,11]

-- ─── COMBINED EXAMPLES ─────────────────────────────────────────────────────

-- Avoid F# overtones, stay in C major, only C/G roots
let modalCtx = hContext "* -F#" "C" "C G"

-- Jazz context: all overtones except C, D major key except F#, specific roots
let jazzCtx = hContext "* -C'" "2# -F#'" "D F# A -A"

-- ─── EDGE CASES ────────────────────────────────────────────────────────────

let empty1 = hContext "-*" "*" "*"        -- Empty overtones (no positive tokens)
let empty2 = hContext "-C -D" "*" "*"     -- Empty overtones (only negatives)
let allButC = hContext "* -C'" "*" "*"    -- All except C

-- IMPORTANT: Prime (') notation behavior:
--   - In OVERTONES: prevents overtone generation (G' = just G pitch, not G overtones)
--   - In KEY: specifies single pitch (G' = pitch 7, not G major scale)
--   - In ROOTS: INVERTED - specifies scale (G = pitch 7, G' = G major scale)
--
-- Why invert prime in roots? Makes roots default to individual pitches (more intuitive):
--   - "C G D" = just those 3 pitches [0,7,2]
--   - "2# C F" = D major + C + F (token-by-token union)
--   - "G'" = G major scale (when you need a scale in roots)
--
-- Removal (-) works with ANY valid token:
--   - '-G' in overtones: removes G overtones
--   - '-G' in key: removes G major scale
--   - '-G' in roots: removes G pitch
--   - '-G'' in overtones/key: removes G pitch
--   - '-G'' in roots: removes G major scale (INVERTED)
--   - '-1b': removes F major scale
--   - '-*': removes all pitches (results in empty set)


-- ───────────────────────────────────────────────────────────────────────────
-- 2.5 Composer Weighting - Stylistic Control
-- ───────────────────────────────────────────────────────────────────────────
-- The composer parameter filters graph edges by historical usage patterns.
-- Each edge in the Neo4j graph stores per-composer weights from YCACL corpus.

-- SINGLE COMPOSER: 100% of that composer's style
prog1 <- gen start 8 "bach" 0.5 defaultContext        -- Bach-style progression
prog2 <- gen start 8 "debussy" 0.5 defaultContext     -- Impressionist style
prog3 <- gen start 8 "mozart" 0.5 defaultContext      -- Classical period

-- MULTIPLE COMPOSERS (EQUAL WEIGHTS): Space-separated names
prog4 <- gen start 8 "bach debussy" 0.5 defaultContext  -- 50/50 blend

-- WEIGHTED BLEND (PERCENTAGE): Use colon syntax
prog5 <- gen start 8 "bach:0.3 debussy:0.7" 0.5 defaultContext  -- 30% Bach, 70% Debussy

-- WEIGHTED BLEND (RATIO): Equivalent to percentage
prog6 <- gen start 8 "bach:3 debussy:7" 0.5 defaultContext  -- Also 30/70 split

-- WILDCARD: Aggregate all composers (no filtering)
prog7 <- gen start 8 "*" 0.5 defaultContext

-- HOW IT WORKS
-- 1. Parser normalizes weights to sum = 1.0
-- 2. Each graph edge has composer weights: {"bach":0.88,"debussy":0.76,...}
-- 3. Score = sum(userWeight[composer] * edgeWeight[composer])
-- 4. Edges with score = 0.0 are filtered out
-- 5. Remaining candidates selected via gamma distribution (entropy controlled)

-- COMPARISON EXAMPLE
do
  let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
  bachProg <- gen start 16 "bach" 0.5 defaultContext
  debussyProg <- gen start 16 "debussy" 0.5 defaultContext

  d1 $ note (harmony bachProg "<0 1 2 3>") # s "superpiano"     -- Traditional
  d2 $ note (harmony debussyProg "<0 1 2 3>") # s "superpiano"  -- Impressionist

hush

-- Pro tip: Use lower entropy (0.3-0.5) with specific composers for
-- more characteristic progressions. Higher entropy (0.8-1.5) explores
-- less-typical transitions while respecting composer preferences.


-- ───────────────────────────────────────────────────────────────────────────
-- 2.5 Progression Type - What You Get Back
-- ───────────────────────────────────────────────────────────────────────────
-- Progression is a sequence of CadenceStates
-- You can inspect it with these functions:

progLength prog1      -- → 8 (number of chords)
progChords prog1      -- → [Chord, Chord, ...] (list of Chord objects)
print prog1           -- Displays 4-column grid with bar numbers

-- Grid format example:
--    1   ||   C maj         |   F maj         |   G 7           |   C maj         |
--    5    |   F maj         |   Dm min        |   G 7           |   C maj         ||

-- The grid shows enharmonic spelling preserved from generation


-- ═══════════════════════════════════════════════════════════════════════════
-- SECTION 3: PATTERN BLOCKS - THE pXX LAUNCHER
-- ═══════════════════════════════════════════════════════════════════════════
-- Goal: Understand the performance paradigm

-- ───────────────────────────────────────────────────────────────────────────
-- 3.1 Pattern Block Anatomy
-- ───────────────────────────────────────────────────────────────────────────
-- Pattern blocks follow this structure: pXX f s r d = dNN $ do ...
-- Four parameters control behavior:
--   f = transformation function (id, slow, fast, rev, etc.)
--   s = progression state (generated Progression)
--   r = repetitions per cycle (typically 1)
--   d = dynamics scalar (function: Double -> Double)

-- Minimal example:
p01 f s r d = d01 $ do
  let o = ch 01  -- MIDI channel 1
  f $ arrange flow s r (-9,9) ["0 1 2 3"] # o

-- Execute the pattern block:
do
  let f = id; r = 1; d = (*0.8); s = prog1
  setbpm 120
  p01 f s r $ d 0.7  -- Apply dynamics (0.7 * 0.8 = 0.56 final)

hush


-- ───────────────────────────────────────────────────────────────────────────
-- 3.2 Multi-Voice Stacking
-- ───────────────────────────────────────────────────────────────────────────
-- Stack multiple arrange calls for polyphonic textures

p02 f s r d = d02 $ do
  let o = ch 02
  f $ stack [
    silence,  -- Keep silence as first layer (legacy convention)

    -- Voice 1: Flowing chords (harmonic bed)
    arrange flow s r (-9,9) ["~", "[0,1,2,3]/4"] # o |* vel 0.8,

    -- Voice 2: Root bass line (low octave)
    arrange root s r (-9,9) ["~", "0*2"] # o |* vel 1 |- oct 2,

    -- Voice 3: Sparse melody (high octave)
    arrange flow s r (-9,9) ["~", "[2 4 5]@3"] # o |* vel 0.6 |+ oct 1
  ] |* vel d

-- Execution:
do
  let f = id; r = 1; d = (*0.8); s = prog1
  setbpm 100
  p02 f s r $ d 0.7

hush

-- Note on pattern syntax:
-- "~" in first position creates rest on beat 1
-- |- oct N shifts down by N octaves
-- |+ oct N shifts up by N octaves
-- |* vel N scales velocity (amplitude)


-- ───────────────────────────────────────────────────────────────────────────
-- 3.3 Pulsar Snippet Integration
-- ───────────────────────────────────────────────────────────────────────────
-- The 'p' snippet in ~/.pulsar/snippets.cson generates this template:
-- Typing 'p' + TAB in Pulsar creates:

{-
p$1 f s r d = d$1 $ do
  let o = ch $1
  f
    $ stack [silence
       -- --
      ,arrange flow (overlapF 0 s) r (-9,9) ["~"
        ,$2
      ]# o |* vel 1
       -- --
    ] |* vel d
  $3
-}

-- Where:
-- $1 = pattern number (01, 02, etc.) - auto-filled
-- $2 = cursor position for pattern content - you type here
-- $3 = cursor position after block - press TAB to jump here


-- ═══════════════════════════════════════════════════════════════════════════
-- SECTION 4: VOICING STRATEGIES
-- ═══════════════════════════════════════════════════════════════════════════
-- Goal: Understand when to use flow/root/lite/bass

-- ───────────────────────────────────────────────────────────────────────────
-- 4.1 Voicing Paradigms Explained
-- ───────────────────────────────────────────────────────────────────────────

-- FLOW: Smoothest voice leading, any inversion allowed
-- - Cyclic dynamic programming optimization (loop-friendly)
-- - Voices may cross for minimal movement
-- - First chord root normalized to [7-18] range (around middle C)
-- - Best for: pads, chords, harmonic beds, smooth progressions

-- ROOT: Root always in bass, compact voicing above
-- - Cyclic DP with root position constraint
-- - Clear harmonic foundation, no voice crossing bass
-- - Best for: bass lines, piano, rhythm section, functional harmony

-- LITE: Literal intervals from database, no optimization
-- - Raw intervals as stored in Neo4j
-- - First root normalized to [7-18] octave range
-- - No voice leading optimization applied
-- - Best for: experimental contexts, atonal music, exact database reproduction

-- BASS: Root note only (single pitch per chord)
-- - Extracts root pitch class only [0-11]
-- - Best for: bass lines, kick drum patterns, monophonic instruments

-- Comparison example - generate and compare voicings:
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
prog <- gen start 4 "*" 0.5 defaultContext

-- Listen to each paradigm (comment out all but one):
-- d1 $ note (pattern $ flow prog) # s "superpiano"
-- d2 $ note (pattern $ root prog) # s "superpiano" |- oct 1
-- d3 $ note (pattern $ lite prog) # s "superpiano"
-- d4 $ note (pattern $ bass prog) # s "superbass" |- oct 2

hush


-- ───────────────────────────────────────────────────────────────────────────
-- 4.2 Voicing in arrange
-- ───────────────────────────────────────────────────────────────────────────
-- arrange function signature:
-- arrange :: VoiceFunction -> Progression -> Pattern Time
--         -> (Int, Int) -> [Pattern Int] -> Pattern ValueMap

-- Examples with different voicings:

p03 f s r d = d03 $ do
  let o = ch 03
  f $ stack [silence
    , arrange flow s r (-12,12) ["~", "[0 1 2]"] # o  -- Wide range, smooth
    ] |* vel d

p04 f s r d = d04 $ do
  let o = ch 04
  f $ stack [silence
    , arrange root s r (-12,0) ["~", "0*4"] # o  -- Low range, root bass
    ] |* vel d

p05 f s r d = d05 $ do
  let o = ch 05
  f $ stack [silence
    , arrange bass s r (-12,12) ["~", "[0 1 2 3]/4"] # o  -- Bass notes only
    ] |* vel d

-- Register filtering explanation:
-- (-12, 12) = 2 octaves around middle C (wide range)
-- (-9, 9)   = ±9 semitones (tighter, more focused range)
-- (-12, 0)  = Low range (bass register)
-- (0, 12)   = High range (treble register)


-- ═══════════════════════════════════════════════════════════════════════════
-- SECTION 5: PROGRESSION MANIPULATION
-- ═══════════════════════════════════════════════════════════════════════════
-- Goal: Transform progressions before playback

-- ───────────────────────────────────────────────────────────────────────────
-- 5.1 Position/Range Operations
-- ───────────────────────────────────────────────────────────────────────────

-- ROTATE: Shift circular position
-- Signature: rotate :: Int -> Progression -> Progression
let prog2 = rotate 2 prog1     -- Shift left by 2 bars
let prog3 = rotate (-1) prog1  -- Shift right by 1 bar (same as rotate 15 for 16-bar)

-- EXCERPT: Extract range (1-indexed, inclusive)
-- Signature: excerpt :: Int -> Int -> Progression -> Progression
let intro = excerpt 1 4 prog1   -- First 4 bars
let outro = excerpt 13 16 prog1 -- Last 4 bars of 16-bar progression

-- REVERSE: Backwards motion (retrograde)
-- Signature: reverse :: Progression -> Progression
let retro = Prelude.reverse prog1  -- Haskell's standard reverse

-- Try it - compare original vs rotated:
-- d1 $ note (harmony prog1 "<0 1 2 3>") # s "superpiano"  -- Original
-- d2 $ note (harmony prog2 "<0 1 2 3>") # s "superpiano"  -- Rotated

hush


-- ───────────────────────────────────────────────────────────────────────────
-- 5.2 Transformation Operations
-- ───────────────────────────────────────────────────────────────────────────

-- TRANSPOSE: Shift pitch by semitones
-- Signature: transposeP :: Int -> Progression -> Progression
let prog_up5 = transposeP 5 prog1      -- Up perfect 4th (C→F)
let prog_down3 = transposeP (-3) prog1 -- Down minor 3rd

-- EXPAND: Repeat each chord n times
-- Signature: expandP :: Int -> Progression -> Progression
let prog_slow = expandP 2 prog1  -- Each chord appears twice (double length)

-- FUSE: Concatenate progressions
-- Signature: fuse2 :: Progression -> Progression -> Progression
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
progA <- gen start 4 "*" 0.5 defaultContext
progB <- gen start 4 "*" 0.8 defaultContext  -- Different entropy
let combined = fuse2 progA progB  -- 8 bars total

-- INTERLEAVE: Alternate chords from two progressions
-- Signature: interleave :: Progression -> Progression -> Progression
let woven = interleave progA progB  -- A1,B1,A2,B2,A3,B3,A4,B4

-- Try it - play the combined progression:
-- d1 $ note (harmony combined "<0 1 2 3 4 5 6 7>") # s "superpiano"

hush


-- ───────────────────────────────────────────────────────────────────────────
-- 5.3 State Management Pattern
-- ───────────────────────────────────────────────────────────────────────────
-- Common live performance pattern: generate once, manipulate in real-time

-- Initial generation (do this once at session start)
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
base <- gen start 16 "*" 0.5 defaultContext

-- Create variations (pure functions, instant)
let intro = excerpt 1 4 base
let verseA = rotate 0 base           -- Identity (no rotation)
let verseB = rotate 4 base           -- Start from bar 5
let chorus = fuse2 (excerpt 1 8 base) (excerpt 9 16 base)
let bridge = transposeP 5 (excerpt 1 8 base)  -- Modulate up
let outro = Prelude.reverse (excerpt 13 16 base)

-- Switch between sections live by changing currentState:
let currentState = intro
-- d1 $ note (harmony currentState "<0 1 2 3>") # s "superpiano"

-- To switch: just re-evaluate with a different section
-- let currentState = verseA
-- let currentState = chorus

hush


-- ═══════════════════════════════════════════════════════════════════════════
-- SECTION 6: OVERLAP - SUSTAIN & LEGATO
-- ═══════════════════════════════════════════════════════════════════════════
-- Goal: Create flowing, sustained textures

-- ───────────────────────────────────────────────────────────────────────────
-- 6.1 Overlap Explained
-- ───────────────────────────────────────────────────────────────────────────
-- Overlap merges pitches from adjacent chords to create sustain/legato effects

-- FORWARD (overlapF): Merge with bars AHEAD
-- Signature: overlapF :: Int -> Progression -> Progression
let s0 = prog1              -- No overlap (original)
let s1 = overlapF 1 prog1   -- Merge with next 1 bar ahead
let s2 = overlapF 2 prog1   -- Merge with next 2 bars ahead

-- BACKWARD (overlapB): Merge with bars BEHIND
-- Signature: overlapB :: Int -> Progression -> Progression
let s3 = overlapB 1 prog1   -- Merge with previous 1 bar

-- BIDIRECTIONAL (overlap): Merge in BOTH directions
-- Signature: overlap :: Int -> Progression -> Progression
let s4 = overlap 1 prog1    -- Merge with prev AND next bar

-- Visual effect example:
-- Original:
--   Chord 1: [C, E, G]
--   Chord 2: [F, A, C]
--
-- With overlapF 1:
--   Chord 1: [C, E, G, F, A, C]  -- Sustains into next chord's pitches
--   Chord 2: [F, A, C]           -- Unchanged


-- ───────────────────────────────────────────────────────────────────────────
-- 6.2 Overlap in Pattern Blocks
-- ───────────────────────────────────────────────────────────────────────────
-- Typical usage: pass overlapped progression to arrange

p06 f s r d = d06 $ do
  let o = ch 06
  f $ stack [silence
    , arrange flow (overlapF 0 s) r (-9,9) ["~", "[0 1 2]"] # o  -- No overlap
    ] |* vel d

p07 f s r d = d07 $ do
  let o = ch 07
  f $ stack [silence
    , arrange flow (overlapF 1 s) r (-9,9) ["~", "[0 1 2]"] # o  -- 1-bar overlap
    ] |* vel d

-- Compare articulated vs legato:
do
  let f = id; r = 1; d = (*0.8); s = prog1
  setbpm 90
  p06 f s r $ d 0.7  -- Articulated (clean transitions)

-- Switch to:
-- do
--   let f = id; r = 1; d = (*0.8); s = prog1
--   setbpm 90
--   p07 f s r $ d 0.7  -- Legato (sustained transitions)

hush


-- ═══════════════════════════════════════════════════════════════════════════
-- SECTION 7: ADVANCED FEATURES
-- ═══════════════════════════════════════════════════════════════════════════
-- Goal: Fine-tune generation behavior

-- ───────────────────────────────────────────────────────────────────────────
-- 7.1 Entropy Tuning
-- ───────────────────────────────────────────────────────────────────────────
-- Entropy controls exploration vs exploitation in generation
-- Low entropy: conservative, stays close to common patterns
-- High entropy: exploratory, seeks unusual transitions

let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext

conservative <- gen start 8 "*" 0.2 ctx  -- Low entropy: predictable, common
balanced <- gen start 8 "*" 1.0 ctx      -- Mid entropy: mixed variety
exploratory <- gen start 8 "*" 2.5 ctx   -- High entropy: unusual, surprising

-- Compare outputs (print to see differences):
print conservative
print exploratory

-- Entropy guidelines:
-- 0.0-0.5: Conservative (functional harmony, common progressions)
-- 0.5-1.0: Balanced (mixture of common and interesting)
-- 1.0-2.0: Exploratory (more unusual choices, jazz-like)
-- 2.0+:    Experimental (highly unusual, atonal tendencies)


-- ───────────────────────────────────────────────────────────────────────────
-- 7.2 Custom Contexts
-- ───────────────────────────────────────────────────────────────────────────
-- Real-world context examples for different musical scenarios:

-- Jazz ii-V-I in Bb major
let jazzCtx = hContext "*" "2b" "C F"  -- Bb major scale, ii(Cm) and V(F) roots

-- E minor pentatonic (pitch palette)
let pentatonic = hContext "E G A B D" "*" "*"  -- Only pentatonic pitches

-- Bass tuning constraint (overtone filtering)
let bassCtx = hContext "E A D G" "*" "*"  -- 4-string bass overtones

-- Modal harmony: Dorian mode on D
let dorian = hContext "*" "D E F G A B C" "*"  -- Dorian scale degrees

-- Blues-influenced (specific pitches and roots)
let bluesCtx = hContext "C Eb F Gb G Bb" "*" "C F G"  -- Blues scale, I-IV-V roots

-- Try different contexts and compare:
prog_jazz <- gen start 8 "*" 0.5 jazzCtx
prog_pent <- gen start 8 "*" 0.5 pentatonic
prog_blues <- gen start 8 "*" 0.5 bluesCtx

print prog_jazz
print prog_pent


-- ───────────────────────────────────────────────────────────────────────────
-- 7.3 Pattern-Based Lookup
-- ───────────────────────────────────────────────────────────────────────────
-- Direct progression indexing with automatic modulo wrap

-- lookupChord: Get single chord at specific index
-- Signature: lookupChord :: Progression -> Int -> Chord
let chord0 = lookupChord prog1 0   -- First chord
let chord4 = lookupChord prog1 4   -- Wraps to chord 0 for 4-chord progression

-- lookupProgression: Pattern of indices → pattern of voicings
-- Signature: lookupProgression :: Progression -> Pattern Int -> Pattern [Int]
let pattern1 = lookupProgression prog1 (run 8)  -- Indices 0-7 cycling
-- d1 $ note (fmap fromIntegral $ fmap head pattern1) # s "superpiano"

-- harmony: Convenience function (lookup + note conversion)
-- Signature: harmony :: Progression -> Pattern Int -> Pattern ValueMap
-- This is the simplest way to play progressions:
-- d1 $ note (harmony prog1 "<0 1 2 3>") # s "superpiano"
-- d2 $ note (harmony prog1 (run 16)) # s "superpiano"  -- 16 notes cycling over 4 chords

hush

-- Pattern indices wrap automatically:
-- 4-chord progression: indices 0,1,2,3,4,5,6,7... map to 0,1,2,3,0,1,2,3...
-- This enables infinite cycling with (run 16), (run 32), etc.


-- ═══════════════════════════════════════════════════════════════════════════
-- SECTION 8: COMPLETE PERFORMANCE TEMPLATE
-- ═══════════════════════════════════════════════════════════════════════════
-- Goal: Production-ready session structure
-- Copy this structure for live performances

-- ───────────────────────────────────────────────────────────────────────────
-- 8.1 SETUP: Generate progressions
-- ───────────────────────────────────────────────────────────────────────────

let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext

-- Generate base material (16 bars)
base <- gen start 16 "*" 0.5 ctx

-- Create song sections (all pure functions, no I/O)
let intro = excerpt 1 4 base
let verseA = rotate 0 base
let verseB = rotate 4 base
let chorus = fuse2 (excerpt 1 8 base) (excerpt 9 16 base)
let bridge = transposeP 5 (excerpt 1 8 base)  -- Modulate up perfect 4th
let outro = Prelude.reverse (excerpt 13 16 base)


-- ───────────────────────────────────────────────────────────────────────────
-- 8.2 PATTERN DEFINITIONS
-- ───────────────────────────────────────────────────────────────────────────

-- Pad (flow voicing, sustained with overlap)
p08 f s r d = d08 $ do
  let o = ch 08
  f $ stack [silence
    , arrange flow (overlapF 1 s) r (-9,9) ["~", "[0,1,2,3]/4"] # o |* vel 0.6
    ] |* vel d

-- Bass (root voicing, low register, no overlap)
p09 f s r d = d09 $ do
  let o = ch 09
  f $ stack [silence
    , arrange root s r (-12,0) ["~", "0*4"] # o |* vel 0.9 |- oct 2
    ] |* vel d

-- Melody (flow voicing, sparse, high register)
p10 f s r d = d10 $ do
  let o = ch 10
  f $ stack [silence
    , arrange flow s r (-9,9) ["~", "[2 4 5]@3"] # o |* vel 0.7 |+ oct 1
    ] |* vel d

-- Arpeggio (bass notes only, rhythmic)
p11 f s r d = d11 $ do
  let o = ch 11
  f $ stack [silence
    , arrange bass s r (-12,12) ["~", "[0 1 2 3 4 5 6 7]/8"] # o |* vel 0.5
    ] |* vel d


-- ───────────────────────────────────────────────────────────────────────────
-- 8.3 PERFORMANCE EXECUTION
-- ───────────────────────────────────────────────────────────────────────────

-- Intro (pad only, sparse)
do
  let f = id; r = 1; d = (*0.8); s = intro
  mapM_ id [hush, setbpm 90, p08 f s r $ d 0.5]

-- Verse A (pad + bass)
-- do
--   let f = id; r = 1; d = (*0.8); s = verseA
--   mapM_ id [p08 f s r $ d 0.6, p09 f s r $ d 0.7]

-- Chorus (all instruments, full energy)
-- do
--   let f = id; r = 1; d = (*0.9); s = chorus
--   mapM_ id [
--     p08 f s r $ d 0.7,
--     p09 f s r $ d 0.8,
--     p10 f s r $ d 0.6,
--     p11 f s r $ d 0.5
--   ]

-- Bridge (transposed, different harmonic area)
-- do
--   let f = id; r = 1; d = (*0.85); s = bridge
--   mapM_ id [p08 f s r $ d 0.6, p10 f s r $ d 0.7]

-- Outro (reversed, pad only, fade)
-- do
--   let f = id; r = 1; d = (*0.7); s = outro
--   mapM_ id [p08 f s r $ d 0.4]

-- Silence
hush


-- ───────────────────────────────────────────────────────────────────────────
-- 8.4 LIVE TRANSFORMATIONS
-- ───────────────────────────────────────────────────────────────────────────

-- Switch progression state mid-performance:
-- let currentState = verseA  -- Change to verseB, chorus, bridge, etc.

-- Apply TidalCycles transformations to f parameter:
-- let f = slow 2     -- Half-speed (double the pattern duration)
-- let f = rev        -- Reverse pattern direction
-- let f = fast 2     -- Double-speed (half the pattern duration)
-- let f = iter 4     -- Rotate pattern over 4 cycles
-- let f = every 4 rev  -- Reverse every 4th cycle

-- Adjust dynamics with d parameter:
-- let d = (*0.5)  -- Quieter (50%)
-- let d = (*1.2)  -- Louder (120%)

-- Change repetitions with r parameter:
-- let r = 0.5     -- Two cycles per bar (faster harmonic rhythm)
-- let r = 2       -- One bar per two cycles (slower harmonic rhythm)


-- ═══════════════════════════════════════════════════════════════════════════
-- SECTION 9: TROUBLESHOOTING & TIPS
-- ═══════════════════════════════════════════════════════════════════════════
-- Goal: Common issues and solutions

{-
ISSUE: "No instance for (Show Progression)"
SOLUTION: Use `print prog` instead of just `prog` in GHCi

ISSUE: Neo4j connection error during generation
SOLUTION: Ensure docker container is running:
  $ docker compose up -d neo4j
  $ curl http://localhost:7474  # Should return HTML

ISSUE: Progression sounds "stuck" on one chord
SOLUTION: Check progLength - may have generated 1 chord only
  progLength prog  -- Should be > 1
  If length is 1, try different starting state or entropy

ISSUE: No sound from pattern block
SOLUTION: Verify MIDI/SuperDirt routing in BootTidal.hs
  - Check dNN outputs are configured (d01-d16)
  - Verify MIDI channels match synthesizer setup
  - Test with simple pattern: d1 $ note "c e g" # s "superpiano"

ISSUE: Overlap creates too much dissonance
SOLUTION: Reduce overlap amount or use different voicing
  - Try overlapF 0 instead of overlapF 2
  - Use root instead of flow voicing (clearer bass)
  - Lower entropy for more consonant progressions

ISSUE: Pattern too dense/sparse
SOLUTION: Adjust register range in arrange
  - Wider range: (-12, 12) for more notes
  - Tighter range: (-6, 6) for fewer notes
  - Adjust pattern: ["0 1 2 3"] vs ["0 2"] vs ["0*8"]

ISSUE: Entropy seems to have no effect
SOLUTION: Check HarmonicContext filters
  - Overly restrictive filters limit candidate pool
  - Try defaultContext to verify entropy behavior
  - Higher entropy needs larger candidate pool to explore

ISSUE: Generation is slow
SOLUTION:
  - Use gen (silent) instead of gen' or gen'' for performance
  - Neo4j query optimization: ensure database is populated
  - Reduce progression length for faster generation

TYPICAL ENTROPY RANGES:
  0.2-0.5: Conservative (classical, functional harmony)
  0.5-1.0: Balanced (pop, jazz standards)
  1.0-2.0: Exploratory (modern jazz, film scores)
  2.0+:    Experimental (avant-garde, atonal)
-}


-- ═══════════════════════════════════════════════════════════════════════════
-- SECTION 10: QUICK REFERENCE
-- ═══════════════════════════════════════════════════════════════════════════
-- Goal: Cheat sheet for common operations

-- ───────────────────────────────────────────────────────────────────────────
-- GENERATION
-- ───────────────────────────────────────────────────────────────────────────
{-
-- Silent (no output)
prog <- gen start 8 "*" 0.5 ctx                        -- All composers
prog <- gen start 8 "bach" 0.5 ctx                     -- Bach only
prog <- gen start 8 "bach debussy" 0.5 ctx             -- Equal blend
prog <- gen start 8 "bach:0.3 debussy:0.7" 0.5 ctx     -- Weighted 30/70

-- Standard diagnostics
prog <- gen' start 8 "*" 0.5 ctx

-- Verbose traces
prog <- gen'' start 8 "*" 0.5 ctx
-}

-- ───────────────────────────────────────────────────────────────────────────
-- CONTEXTS
-- ───────────────────────────────────────────────────────────────────────────
{-
let ctx = defaultContext                      -- No filtering
let ctx = hContext "E A D G" "*" "*"          -- Bass tuning overtones
let ctx = hContext "*" "1#" "*"               -- G major key
let ctx = hContext "*" "*" "C G"              -- C and G roots only
let ctx = hContext "E A D G" "##" "D F# A"    -- Combined filters
-}

-- ───────────────────────────────────────────────────────────────────────────
-- STARTING STATES
-- ───────────────────────────────────────────────────────────────────────────
{-
let major = initCadenceState 0 "C" [0,4,7] FlatSpelling
let minor = initCadenceState 0 "A" [0,3,7] FlatSpelling
let dim   = initCadenceState 0 "B" [0,3,6] SharpSpelling
let sus4  = initCadenceState 0 "D" [0,5,7] FlatSpelling
let dom7  = initCadenceState 0 "G" [0,4,7,10] FlatSpelling
-}

-- ───────────────────────────────────────────────────────────────────────────
-- VOICING PARADIGMS
-- ───────────────────────────────────────────────────────────────────────────
{-
arrange flow s r range patterns  -- Smoothest voice leading (any inversion)
arrange root s r range patterns  -- Root in bass (functional harmony)
arrange lite s r range patterns  -- Literal intervals (no optimization)
arrange bass s r range patterns  -- Bass note only (monophonic)
-}

-- ───────────────────────────────────────────────────────────────────────────
-- OVERLAP
-- ───────────────────────────────────────────────────────────────────────────
{-
overlapF n prog  -- Forward: merge with next n bars
overlapB n prog  -- Backward: merge with prev n bars
overlap n prog   -- Both directions: merge with ±n bars
-}

-- ───────────────────────────────────────────────────────────────────────────
-- MANIPULATION
-- ───────────────────────────────────────────────────────────────────────────
{-
rotate n prog           -- Shift position by n bars
excerpt m n prog        -- Extract bars m to n (1-indexed)
transposeP n prog       -- Transpose by n semitones
Prelude.reverse prog    -- Backwards motion (retrograde)
fuse2 progA progB       -- Concatenate two progressions
interleave progA progB  -- Alternate chords from two progressions
expandP n prog          -- Repeat each chord n times
-}

-- ───────────────────────────────────────────────────────────────────────────
-- PATTERN BLOCKS
-- ───────────────────────────────────────────────────────────────────────────
{-
pNN f s r d = dNN $ do
  let o = ch NN
  f $ arrange voicing s r range patterns # o
-}

-- ───────────────────────────────────────────────────────────────────────────
-- EXECUTION
-- ───────────────────────────────────────────────────────────────────────────
{-
do
  let f = id; r = 1; d = (*0.8); s = prog
  mapM_ id [hush, setbpm 120, p01 f s r $ d 0.7]
-}

-- ───────────────────────────────────────────────────────────────────────────
-- INSPECTION
-- ───────────────────────────────────────────────────────────────────────────
{-
progLength prog   -- Number of chords
print prog        -- Visual 4-column grid
progChords prog   -- List of Chord objects
progCadences prog -- List of Cadence objects
-}

-- ───────────────────────────────────────────────────────────────────────────
-- DIRECT PLAYBACK
-- ───────────────────────────────────────────────────────────────────────────
{-
d1 $ note (harmony prog "<0 1 2 3>") # s "superpiano"
d2 $ note (harmony prog (run 16)) # s "superpiano"
-}


-- ═══════════════════════════════════════════════════════════════════════════
-- END OF USER GUIDE
-- ═══════════════════════════════════════════════════════════════════════════
--
-- Next steps:
--   1. Execute blocks sequentially to learn workflow
--   2. Modify examples to explore behavior
--   3. Build your own pattern blocks and progressions
--   4. Experiment with different contexts and entropy values
--
-- For more information:
--   - README.md: Architecture and theory
--   - USER_GUIDE.md: Detailed technical documentation
--   - live/testTidal.tidal: Modern working example
--
-- Generated by 'The Harmonic Algorithm' -> https://github.com/OscarSouth/theHarmonicAlgorithm
