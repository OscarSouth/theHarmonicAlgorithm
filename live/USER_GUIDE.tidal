-- ═══════════════════════════════════════════════════════════
-- THE HARMONIC ALGORITHM - USER GUIDE
-- ═══════════════════════════════════════════════════════════
-- Interactive documentation for TidalCycles integration
-- Work through this file top to bottom for a complete guide
--
-- Prerequisites:
--   1. Neo4j running (docker compose up -d neo4j)
--   2. BootTidal.hs loaded with Harmonic.Lib
--   3. MIDI piano on channel 1 (p01)
--   4. TidalCycles + SuperDirt running


-- ═══════════════════════════════════════════════════════════
-- SECTION 1: QUICK START
-- ═══════════════════════════════════════════════════════════
-- Goal: Get sound in 30 seconds

-- Step 1: Generate a 4-chord progression
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = defaultContext
prog <- gen start 4 "*" 0.5 ctx

-- Step 2: Play on MIDI channel 1 (piano)
d01 $ note (harmony prog "<0 1 2 3>") # ch 01

-- Step 3: Stop playback
hush


-- ═══════════════════════════════════════════════════════════
-- SECTION 2: CORE BUILDING BLOCKS
-- ═══════════════════════════════════════════════════════════
-- Goal: Understand the foundation

-- ───────────────────────────────────────────────────────────
-- 2.1 CadenceState - Where to Start
-- ───────────────────────────────────────────────────────────

-- CadenceState defines your starting point
-- Signature:
--   initCadenceState :: Int -> String -> [Int]
--                    -> EnharmonicSpelling -> CadenceState

let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    -- 0          = movement (semitones from prior, 0 for first)
    -- "C"        = root note name
    -- [0,4,7]    = intervals (C major triad)
    -- FlatSpelling = prefer flats in output

-- Common chord qualities:
let maj  = initCadenceState 0 "C" [0,4,7] FlatSpelling
let min  = initCadenceState 0 "A" [0,3,7] FlatSpelling
let dim  = initCadenceState 0 "B" [0,3,6] SharpSpelling
let sus4 = initCadenceState 0 "D" [0,5,7] FlatSpelling
let aug  = initCadenceState 0 "C" [0,4,8] FlatSpelling
let dom7 = initCadenceState 0 "G" [0,4,7,10] FlatSpelling


-- ───────────────────────────────────────────────────────────
-- 2.2 HarmonicContext - Constraints
-- ───────────────────────────────────────────────────────────

-- HarmonicContext filters what chords can appear
-- Three independent filters: overtones, key, roots
-- Signature:
--   hContext :: String -> String -> String
--            -> HarmonicContext

let ctx = defaultContext  -- No filtering: "*" "*" "*"

-- OVERTONE FILTERING
-- Limits to pitches in overtone series of specified notes
let bassCtx = hContext "E A D G" "*" "*"
    -- Bass tuning overtones only

let guitarCtx = hContext "E A D G B E" "*" "*"
    -- Guitar tuning overtones

-- KEY FILTERING
-- Limits to pitches in a specific key/scale
let gMajor  = hContext "*" "1#" "*"    -- G major (1 sharp)
let dMajor  = hContext "*" "##" "*"    -- D major (2 sharps)
let cMajor  = hContext "*" "C" "*"     -- C major (natural)
let fMajor  = hContext "*" "1b" "*"    -- F major (1 flat)
let bbMajor = hContext "*" "2b" "*"    -- Bb major (2 flats)

-- ROOT FILTERING
-- Limits to specific root notes
let cAndG = hContext "*" "*" "C G"
    -- Only C and G roots

let fifthsOnly = hContext "*" "*" "C G D A"
    -- Circle of fifths subset

-- COMBINED FILTERING
-- Apply multiple constraints simultaneously
let jazzCtx = hContext "*" "##" "D F# A"
    -- D major key, specific roots

-- Key filtering is STRICT:
-- All pitches in generated chords must be in the key
-- This includes roots, thirds, fifths, sevenths, extensions
-- Example: D major filter allows only D E F# G A B C#
-- Rejected: any chord containing C, Eb, Gb, Ab, Bb


-- ───────────────────────────────────────────────────────────
-- 2.3 Generation - Creating Progressions
-- ───────────────────────────────────────────────────────────

-- Three generation functions with different verbosity:
--   genSilent  :: No output (IO Progression)
--   genStandard :: Compact diagnostics (IO Progression)
--   genVerbose  :: Full traces (IO Progression)
--
-- Alias: gen = genSilent

-- Simple generation (8 bars, C major)
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = hContext "*" "C" "*"  -- C major key filter
prog <- gen start 8 "*" 0.5 ctx

-- Play on p01 (MIDI piano)
d01 $ note (harmony prog "<0 1 2 3 4 5 6 7>") # ch 01

-- COMPOSER SPECIFICATION
-- "*" = wildcard (all composers equally weighted)
-- "bach" = single composer
-- "debussy:0.75 bach:0.25" = weighted blend (75% Debussy)
-- "ravel stravinsky mozart:2" = equal weight (2 = double)

let comp1 = "*"  -- Wildcard (most common)
let comp2 = "debussy:0.75 bach:0.25"  -- Blend
prog1 <- gen start 8 comp1 0.5 ctx
prog2 <- gen start 8 comp2 0.6 ctx

-- ENTROPY (0.0 - 2.5)
-- Controls exploration vs exploitation
-- Practical range: 0.3 - 0.8
--   0.3 = very conservative (predictable)
--   0.5 = balanced (default)
--   0.8 = exploratory (adventurous)

prog1 <- gen start 8 "*" 0.3 ctx  -- Conservative
prog2 <- gen start 8 "*" 0.5 ctx  -- Balanced
prog3 <- gen start 8 "*" 0.8 ctx  -- Exploratory

-- Breaking long lines (80-char max):
-- Before:
-- prog <- gen (initCadenceState 0 "C" [0,4,7] FlatSpelling)
--   8 "debussy:0.75 bach:0.25" 0.5 (hContext "*" "C" "*")

-- After:
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = hContext "*" "C" "*"
    comp = "debussy:0.75 bach:0.25"
prog <- gen start 8 comp 0.5 ctx


-- ═══════════════════════════════════════════════════════════
-- SECTION 3: PATTERN LAUNCHER BLOCKS
-- ═══════════════════════════════════════════════════════════
-- Goal: Understand the pXX paradigm

-- ───────────────────────────────────────────────────────────
-- 3.1 Pattern Block Anatomy
-- ───────────────────────────────────────────────────────────

-- Pattern blocks follow: pXX f s r d = dNN $ do ...
-- Four parameters control behavior:
--   f = transformation function (id, slow, fast, rev, etc.)
--   s = progression state (generated Progression)
--   r = repetitions per cycle (typically 1)
--   d = dynamics scalar (function: Double -> Double)

-- Minimal example (MIDI piano on channel 1):
p01 f s r d = d01 $ do
  let o = ch 01  -- MIDI channel 1
  f $ arrange flow s r (-9,9) ["0 1 2 3"] # o

-- Execute the pattern block:
do
  let f = id; r = 1; d = (*0.8); s = prog
  setbpm 120
  p01 f s r $ d 0.7  -- Apply dynamics (0.7 * 0.8 = 0.56)

hush


-- ───────────────────────────────────────────────────────────
-- 3.2 Multi-Voice Stacking
-- ───────────────────────────────────────────────────────────

-- Stack multiple arrange calls for polyphonic textures
-- Real launcher pattern from actual usage:

p03 f s r d = d03 $ do
  let o = ch 03  -- MIDI channel 3
  f $ stack [
    silence,  -- Keep silence first (legacy convention)

    -- Voice 1: Flowing chords (harmonic bed)
    arrange flow s r (-9,9) ["~", "[0,1,2,3]/4"]
      # o |* vel 0.8,

    -- Voice 2: Root bass line (low octave)
    arrange root s r (-9,9) ["~", "0*2"]
      # o |* vel 1 |- oct 2
  ] |* vel d

-- Execution:
do
  let f = id; r = 1; d = (*0.8); s = prog
  setbpm 100
  p03 f s r $ d 0.7

hush

-- Pattern syntax notes:
-- "~" = rest
-- |- oct N = shift down by N octaves
-- |+ oct N = shift up by N octaves
-- |* vel N = scale velocity (amplitude)


-- ───────────────────────────────────────────────────────────
-- 3.3 Transformation Functions (f parameter)
-- ───────────────────────────────────────────────────────────

-- The 'f' parameter accepts time transformation functions:

-- Identity (no change):
let f = id
p01 f prog 1 $ (*0.8) 0.7

-- Slow down by 2x:
let f = slow 2
p01 f prog 1 $ (*0.8) 0.7

-- Speed up by 2x:
let f = fast 2
p01 f prog 1 $ (*0.8) 0.7

-- Reverse:
let f = rev
p01 f prog 1 $ (*0.8) 0.7

-- Combine transformations:
let f = slow 2 . rev  -- Slow AND reverse
p01 f prog 1 $ (*0.8) 0.7


-- ───────────────────────────────────────────────────────────
-- 3.4 80-Character Line Breaking
-- ───────────────────────────────────────────────────────────

-- Long arrange calls must be broken for 80-char limit:

-- Before (>80 chars):
-- arrange flow s r (-9,9) ["~", "[0,1,2,3]/4"]
--   # o |* vel 0.8 |+ oct 1,

-- After (≤80 chars):
arrange flow s r (-9,9) ["~", "[0,1,2,3]/4"]
  # o |* vel 0.8 |+ oct 1,

-- List definitions (vertical alignment):
-- Before (>80 chars):
-- chords = [[0,4,7], [5,9,0], [7,11,2], [0,4,7]]

-- After (≤80 chars):
chords = [
    [0,4,7],    -- C major
    [5,9,0],    -- F major
    [7,11,2],   -- G major
    [0,4,7]     -- C major
  ]

-- Comments (break at 80):
-- Before (>80 chars):
-- This is a very long comment explaining something in detail

-- After (≤80 chars):
-- This is a very long comment explaining something
-- in detail across multiple lines


-- ───────────────────────────────────────────────────────────
-- 3.5 Complete Launcher Example
-- ───────────────────────────────────────────────────────────

-- Full production-ready launcher with all features:

p01 f s r d = d01 $ do
  let o = ch 01
  f $ stack [
    silence,

    -- Chords (flow voicing)
    arrange flow s r (-9,9) ["~", "[0,1,2,3]/4"]
      # o |* vel 0.8,

    -- Bass (root voicing, low octave)
    arrange root s r (-9,9) ["~", "0*2"]
      # o |* vel 1 |- oct 2,

    -- Melody (flow voicing, high octave)
    arrange flow s r (-9,9) ["~", "[2 4 5]@3"]
      # o |* vel 0.6 |+ oct 1
  ] |* vel d

-- Generate progression and perform:
do
  let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
      ctx = hContext "*" "C" "*"
  prog <- gen start 8 "*" 0.5 ctx

  let f = id; r = 1; d = (*0.8)
  setbpm 120
  p01 f prog r $ d 0.7

hush


-- ═══════════════════════════════════════════════════════════
-- SECTION 4: VOICING STRATEGIES
-- ═══════════════════════════════════════════════════════════
-- Goal: Understand flow vs root vs lite vs bass

-- Four voicing strategies control how chords are arranged:
--   flow - Smoothest voice leading (any inversion)
--   root - Root always in bass (root position)
--   lite - Literal (first-root normalized, no optimization)
--   bass - Bass note only (single note)


-- ───────────────────────────────────────────────────────────
-- 4.1 flow - Smooth Voice Leading
-- ───────────────────────────────────────────────────────────

-- Optimizes for minimal melodic movement between chords
-- Allows any inversion to achieve smoothest transitions
-- Best for: pads, ensemble sounds, harmonic beds

let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = hContext "*" "C" "*"
prog <- gen start 4 "*" 0.5 ctx

-- Play with flow voicing (smooth transitions):
d01 $ note (harmony prog "<0 1 2 3>") # ch 01

-- Or explicit flow call:
d01 $ note (flow prog "<0 1 2 3>") # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 4.2 root - Root Position
-- ───────────────────────────────────────────────────────────

-- Root note always in bass (lowest voice)
-- Clear harmonic structure, strong bass line
-- Best for: lead lines, clear progressions, classical style

d01 $ note (root prog "<0 1 2 3>") # ch 01

-- Compare to flow (same progression, different voicing):
d02 $ note (flow prog "<0 1 2 3>") # ch 02

hush


-- ───────────────────────────────────────────────────────────
-- 4.3 lite - Literal (No Optimization)
-- ───────────────────────────────────────────────────────────

-- Presents chords as-is (first-root normalized)
-- No voice leading optimization
-- Best for: exact reproduction, debugging, algorithmic use

d01 $ note (lite prog "<0 1 2 3>") # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 4.4 bass - Bass Note Only
-- ───────────────────────────────────────────────────────────

-- Extracts only the bass note (lowest voice)
-- Single-note line following progression
-- Best for: kick drum patterns, bass lines, percussion

-- Bass line on p01 (low octave):
d01 $ note (bass prog "<0 1 2 3>")
      # ch 01 |- oct 2

-- Or with explicit bass call:
d01 $ note (voiceBy Bass prog "<0 1 2 3>")
      # ch 01 |- oct 2

hush


-- ───────────────────────────────────────────────────────────
-- 4.5 Comparison Table
-- ───────────────────────────────────────────────────────────

-- Same progression, four voicing strategies side-by-side:

let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = hContext "*" "C" "*"
prog <- gen start 4 "*" 0.5 ctx

do
  setbpm 80

  -- flow: Smoothest voice leading (any inversion)
  d01 $ note (flow prog "<0 1 2 3>") # ch 01

  -- root: Root position (root in bass)
  d02 $ note (root prog "<0 1 2 3>")
        # ch 02 |- oct 1

  -- lite: Literal (first-root normalized)
  d03 $ note (lite prog "<0 1 2 3>") # ch 03

  -- bass: Bass note only (single note)
  d04 $ note (bass prog "<0 1 2 3>")
        # ch 04 |- oct 2

hush


-- ───────────────────────────────────────────────────────────
-- 4.6 When to Use Which Voicing
-- ───────────────────────────────────────────────────────────

-- flow:
--   ✓ Pads, ensemble sounds, harmonic beds
--   ✓ Smooth, connected textures
--   ✓ Most versatile for general use
--   Example: Strings, synth pads, piano chords

-- root:
--   ✓ Lead lines, melody harmonization
--   ✓ Clear harmonic structure
--   ✓ Classical progressions
--   Example: Piano, guitar, classical ensemble

-- lite:
--   ✓ Exact reproduction of generated chords
--   ✓ Debugging voicing issues
--   ✓ Algorithmic composition
--   Example: Testing, direct control

-- bass:
--   ✓ Kick drum patterns
--   ✓ Bass lines (synth, upright, electric)
--   ✓ Percussion following harmony
--   Example: Kick following root, bass guitar


-- ───────────────────────────────────────────────────────────
-- 4.7 Voicing in arrange Function
-- ───────────────────────────────────────────────────────────

-- The arrange function accepts voicing as first parameter:
-- arrange :: Voicing -> Progression -> Int
--         -> (Int, Int) -> [String] -> Pattern Int

-- Voicing options: flow, root, lite, bass

p01 f s r d = d01 $ do
  let o = ch 01
  f $ stack [
    silence,

    -- Chords with flow voicing (smooth):
    arrange flow s r (-9,9) ["~", "[0,1,2,3]/4"]
      # o |* vel 0.8,

    -- Bass with root voicing (root in bass):
    arrange root s r (-9,9) ["~", "0*2"]
      # o |* vel 1 |- oct 2,

    -- Single bass note (bass voicing):
    arrange bass s r (-9,9) ["~", "0*4"]
      # o |* vel 1.2 |- oct 2
  ] |* vel d

-- Execute:
do
  let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
      ctx = hContext "*" "C" "*"
  prog <- gen start 8 "*" 0.5 ctx

  let f = id; r = 1; d = (*0.8)
  setbpm 100
  p01 f prog r $ d 0.7

hush


-- ═══════════════════════════════════════════════════════════
-- SECTION 5: PROGRESSION MANIPULATION
-- ═══════════════════════════════════════════════════════════
-- Goal: Transform progressions in real-time

-- Seven transformation functions for live performance:
--   rotate     - Cycle starting position
--   excerpt    - Extract range
--   transposeP - Shift pitch
--   reverse    - Reverse order
--   fuse       - Interleave two progressions
--   expandP    - Repeat chords
--   progOverlapF - Add passing tones


-- ───────────────────────────────────────────────────────────
-- 5.1 rotate - Cycle Starting Position
-- ───────────────────────────────────────────────────────────

-- Rotate progression by N positions (positive or negative)
-- Useful for: starting at different points, creating variation

let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = hContext "*" "C" "*"
prog <- gen start 8 "*" 0.5 ctx

-- Original:
d01 $ note (harmony prog "<0 1 2 3 4 5 6 7>") # ch 01

-- Rotate by 2 (start at chord 3):
let rotated = rotate 2 prog
d01 $ note (harmony rotated "<0 1 2 3 4 5 6 7>") # ch 01

-- Rotate by -1 (start at last chord):
let rotatedNeg = rotate (-1) prog
d01 $ note (harmony rotatedNeg "<0 1 2 3 4 5 6 7>")
      # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 5.2 excerpt - Extract Range
-- ───────────────────────────────────────────────────────────

-- Extract subsection of progression (start, end inclusive)
-- Useful for: verse/chorus separation, loop creation

prog <- gen start 16 "*" 0.5 ctx

-- Original (16 chords):
d01 $ note (harmony prog "<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>")
      # ch 01

-- Extract bars 4-7 (indices 4-7):
let verse = excerpt 4 7 prog
d01 $ note (harmony verse "<0 1 2 3>") # ch 01

-- Extract bars 8-11 (indices 8-11):
let chorus = excerpt 8 11 prog
d01 $ note (harmony chorus "<0 1 2 3>") # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 5.3 transposeP - Shift Pitch
-- ───────────────────────────────────────────────────────────

-- Transpose entire progression by N semitones
-- Useful for: key changes, harmonic variation

prog <- gen start 8 "*" 0.5 ctx

-- Original (C major context):
d01 $ note (harmony prog "<0 1 2 3 4 5 6 7>") # ch 01

-- Transpose up 5 semitones (to F):
let transposed = transposeP 5 prog
d01 $ note (harmony transposed "<0 1 2 3 4 5 6 7>")
      # ch 01

-- Transpose down 3 semitones (to A):
let transposedDown = transposeP (-3) prog
d01 $ note (harmony transposedDown "<0 1 2 3 4 5 6 7>")
      # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 5.4 reverse - Reverse Order
-- ───────────────────────────────────────────────────────────

-- Reverse progression order (last chord first)
-- Useful for: retrograde, creating variation

prog <- gen start 8 "*" 0.5 ctx

-- Original:
d01 $ note (harmony prog "<0 1 2 3 4 5 6 7>") # ch 01

-- Reversed:
let reversed = reverse prog
d01 $ note (harmony reversed "<0 1 2 3 4 5 6 7>")
      # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 5.5 fuse - Interleave Progressions
-- ───────────────────────────────────────────────────────────

-- Combine two progressions by interleaving
-- Useful for: creating composite progressions, mashups

let start1 = initCadenceState 0 "C" [0,4,7] FlatSpelling
    start2 = initCadenceState 0 "A" [0,3,7] FlatSpelling
    ctx = hContext "*" "C" "*"

prog1 <- gen start1 4 "*" 0.5 ctx
prog2 <- gen start2 4 "*" 0.5 ctx

-- Original prog1:
d01 $ note (harmony prog1 "<0 1 2 3>") # ch 01

-- Original prog2:
d01 $ note (harmony prog2 "<0 1 2 3>") # ch 01

-- Fused (interleaved):
let fused = fuse prog1 prog2
d01 $ note (harmony fused "<0 1 2 3 4 5 6 7>") # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 5.6 expandP - Repeat Chords
-- ───────────────────────────────────────────────────────────

-- Repeat each chord N times
-- Useful for: slowing harmonic rhythm, creating space

prog <- gen start 4 "*" 0.5 ctx

-- Original (4 chords):
d01 $ note (harmony prog "<0 1 2 3>") # ch 01

-- Expand by 2 (each chord twice, 8 total):
let expanded = expandP 2 prog
d01 $ note (harmony expanded "<0 1 2 3 4 5 6 7>")
      # ch 01

-- Expand by 4 (each chord 4 times, 16 total):
let expanded4 = expandP 4 prog
d01 $ note (harmony expanded4
      "<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>")
      # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 5.7 progOverlapF - Add Passing Tones
-- ───────────────────────────────────────────────────────────

-- Add overlap/passing tones between chords
-- Parameter: number of semitones to overlap forward
-- Useful for: chromatic movement, melodic interest

prog <- gen start 8 "*" 0.5 ctx

-- Original (no overlap):
d01 $ note (harmony prog "<0 1 2 3 4 5 6 7>") # ch 01

-- Add 1-semitone overlap (chromatic approach):
let overlap1 = progOverlapF 1 prog
d01 $ note (harmony overlap1 "<0 1 2 3 4 5 6 7>")
      # ch 01

-- Add 2-semitone overlap (whole-step approach):
let overlap2 = progOverlapF 2 prog
d01 $ note (harmony overlap2 "<0 1 2 3 4 5 6 7>")
      # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 5.8 Combining Transformations
-- ───────────────────────────────────────────────────────────

-- Chain transformations for complex results:

prog <- gen start 8 "*" 0.5 ctx

-- Rotate, then transpose, then reverse:
let complex = reverse $ transposeP 5 $ rotate 2 prog
d01 $ note (harmony complex "<0 1 2 3 4 5 6 7>")
      # ch 01

-- Extract section, expand, add overlap:
let section = progOverlapF 1 $ expandP 2 $ excerpt 2 5 prog
d01 $ note (harmony section "<0 1 2 3 4 5 6 7>")
      # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 5.9 Live Performance Example
-- ───────────────────────────────────────────────────────────

-- Use transformations in launcher blocks for live control:

p01 f s r d = d01 $ do
  let o = ch 01
  f $ stack [
    silence,

    -- Chords (original):
    arrange flow s r (-9,9) ["~", "[0,1,2,3]/4"]
      # o |* vel 0.8,

    -- Bass (transposed version):
    arrange root (transposeP 7 s) r (-9,9) ["~", "0*2"]
      # o |* vel 1 |- oct 2
  ] |* vel d

-- Execute with transformations:
do
  let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
      ctx = hContext "*" "C" "*"
  prog <- gen start 8 "*" 0.5 ctx

  let f = id; r = 1; d = (*0.8)
  setbpm 100

  -- Play original:
  p01 f prog r $ d 0.7

  -- Play rotated (shift starting position):
  p01 f (rotate 2 prog) r $ d 0.7

  -- Play reversed (retrograde):
  p01 f (reverse prog) r $ d 0.7

  -- Play section only:
  p01 f (excerpt 2 5 prog) r $ d 0.7

hush


-- ═══════════════════════════════════════════════════════════
-- SECTION 6: B2 - CHORD/SCALE/MELODY PARADIGM
-- ═══════════════════════════════════════════════════════════
-- Goal: Master explicit construction & composition workflow

-- The B2 paradigm separates three musical layers:
-- 1. HARMONY - Chord progressions (pitch-class lists)
-- 2. SCALE   - Available pitches for melody (independent)
-- 3. MELODY  - Scale-relative patterns (transformable)

-- Benefits:
-- ✓ Compose without probabilistic generation
-- ✓ Transform melody while preserving harmonic structure
-- ✓ Experiment with form (AABA → ABAB) without rewriting
-- ✓ Manual scale composition (independent of harmony)
-- ✓ Switch mechanism (harmony becomes scale source)


-- ───────────────────────────────────────────────────────────
-- 6.1 fromChords - Explicit Construction
-- ───────────────────────────────────────────────────────────

-- Three functions for building progressions from chord lists:
--   fromChordsFlat  :: [[Int]] -> Progression
--   fromChordsSharp :: [[Int]] -> Progression
--   prog            :: EnharmonicSpelling -> [[Int]]
--                   -> Progression  (legacy alias)

-- Method 1: Direct pitch-class lists (flat spelling)
simpleProg = fromChordsFlat [
    [0, 4, 7],    -- C major
    [5, 9, 0],    -- F major
    [7, 11, 2],   -- G major
    [0, 4, 7]     -- C major (I-IV-V-I)
  ]

-- Play on p01 (MIDI piano):
d01 $ note (harmony simpleProg "<0 1 2 3>") # ch 01

hush

-- Method 2: Sharp spelling preference
sharpProg = fromChordsSharp [
    [0, 4, 7],    -- C major
    [2, 6, 9],    -- D major
    [7, 11, 2]    -- G major
  ]

d01 $ note (harmony sharpProg "<0 1 2>") # ch 01

hush

-- Method 3: Legacy alias (explicit spelling)
legacyProg = prog FlatSpelling [
    [0, 4, 7],
    [5, 9, 0]
  ]

d01 $ note (harmony legacyProg "<0 1>") # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 6.2 Note Name Syntax - Readable Notation
-- ───────────────────────────────────────────────────────────

-- Use note names instead of pitch-class integers
-- Available: C, C', Db, D, D', Eb, E, F, F', Gb, G, G', Ab,
--            A, A', Bb, B
-- (Primes = sharps: C' = C#, F' = F#, etc.)

-- notesToPCs converts note lists to pitch-class integers:
-- notesToPCs :: [NoteName] -> [Int]

-- Examples:
-- notesToPCs [C, E, G]     -> [0, 4, 7]
-- notesToPCs [D, F', A]    -> [2, 6, 9]
-- notesToPCs [Bb, D, F]    -> [10, 2, 5]

-- Use with fromChords for readable progressions:
readableProg = fromChordsSharp [
    notesToPCs [C, E, G],     -- C major
    notesToPCs [D, F', A],    -- D major
    notesToPCs [G, B, D]      -- G major
  ]

d01 $ note (harmony readableProg "<0 1 2>") # ch 01

hush

-- Mix notations (names + pitch classes):
mixedProg = fromChordsFlat [
    notesToPCs [C, E, G],     -- Note names
    [5, 9, 0],                -- Pitch classes
    notesToPCs [G, B, D]      -- Note names
  ]

d01 $ note (harmony mixedProg "<0 1 2>") # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 6.3 Form Transformation - AABA Paradigm
-- ───────────────────────────────────────────────────────────

-- Define sections separately, then assemble different forms:

-- Define A section (2 chords):
aSection = [
    notesToPCs [C, E, G],     -- C major
    notesToPCs [F, A, C]      -- F major
  ]

-- Define B section (2 chords):
bSection = [
    notesToPCs [G, B, D],     -- G major
    notesToPCs [D, F', A]     -- D major
  ]

-- Assemble different forms:
form1 = concat [aSection, aSection, bSection, aSection]
  -- AABA (original, 8 chords)

form2 = concat [aSection, bSection, aSection, bSection]
  -- ABAB (alternate, 8 chords)

form3 = concat [aSection, aSection, bSection, bSection]
  -- AABB (variation, 8 chords)

-- Create progressions from forms:
state1 = fromChordsSharp form1  -- AABA
state2 = fromChordsSharp form2  -- ABAB
state3 = fromChordsSharp form3  -- AABB

-- Play different forms:
d01 $ note (harmony state1 "<0 1 2 3 4 5 6 7>") # ch 01
hush

d01 $ note (harmony state2 "<0 1 2 3 4 5 6 7>") # ch 01
hush

d01 $ note (harmony state3 "<0 1 2 3 4 5 6 7>") # ch 01
hush


-- ───────────────────────────────────────────────────────────
-- 6.4 Switch Mechanism - Harmony as Scale Source
-- ───────────────────────────────────────────────────────────

-- Three approaches to mapping melody:
--   1. Explicit scales (manual scale definitions)
--   2. Use harmony as scales (chord tones = scale)
--   3. Harmony with overlap (chord + passing tones)

-- Create harmony progression first:
harmonyProg = fromChordsFlat [
    [0, 4, 7],    -- C major
    [5, 9, 0],    -- F major
    [7, 11, 2]    -- G major
  ]


-- APPROACH 1: Explicit scales (independent)
-- Define scales manually (can differ from harmony):
scales = [
    [0, 2, 4, 7, 9],      -- C major pentatonic
    [0, 2, 4, 5, 9],      -- F major pentatonic
    [0, 2, 4, 7, 9]       -- G major pentatonic
  ]

melodyState1 = fromChordsFlat scales

-- Play harmony + melody separately:
d01 $ note (harmony harmonyProg "<0 1 2>") # ch 01

d02 $ note (harmony melodyState1 "[0 2 4]")
      # ch 02 |+ oct 1

hush


-- APPROACH 2: Use harmony as scales (switch!)
-- Melody maps directly to chord tones:
melodyState2 = harmonyProg  -- Same progression

d01 $ note (harmony harmonyProg "<0 1 2>") # ch 01

d02 $ note (harmony melodyState2 "[0 1 2]")
      # ch 02 |+ oct 1

hush


-- APPROACH 3: Harmony with overlap (passing tones)
-- Adds chromatic approach tones between chords:
melodyState3 = progOverlapF 1 harmonyProg

d01 $ note (harmony harmonyProg "<0 1 2>") # ch 01

d02 $ note (harmony melodyState3 "[0 1 2 3]")
      # ch 02 |+ oct 1

hush


-- ───────────────────────────────────────────────────────────
-- 6.5 Complete Example 1 - Simple Diatonic Progression
-- ───────────────────────────────────────────────────────────

-- I-vi-IV-V progression in C major with melody

-- Step 1: Define harmony (chords)
harmony = fromChordsFlat [
    notesToPCs [C, E, G],     -- I  (C major)
    notesToPCs [A, C, E],     -- vi (A minor)
    notesToPCs [F, A, C],     -- IV (F major)
    notesToPCs [G, B, D]      -- V  (G major)
  ]

-- Step 2: Define scale (C major pentatonic for all 4 chords)
scale = fromChordsFlat [
    [0, 2, 4, 7, 9],    -- C major pentatonic (for chord 1)
    [0, 2, 4, 7, 9],    -- C major pentatonic (for chord 2)
    [0, 2, 4, 7, 9],    -- C major pentatonic (for chord 3)
    [0, 2, 4, 7, 9]     -- C major pentatonic (for chord 4)
  ]

-- Step 3: Define melody pattern (scale-relative indices)
melody = slow 4 $ slowcat [
    "0 2 4 2",       -- C E G E
    "0 -2 0 2",      -- C A C E
    "4 2 0 -2",      -- G E C A
    "0 2 4 7"        -- C E G B (reaching up)
  ]

-- Step 4: Perform
do
  setbpm 100

  -- Harmony (chords):
  d01 $ note (harmony harmony "<0 1 2 3>") # ch 01

  -- Melody (scale-relative):
  d02 $ note (harmony scale melody)
        # ch 02 |+ oct 1 |* vel 0.8

hush


-- ───────────────────────────────────────────────────────────
-- 6.6 Complete Example 2 - Jazz Progression
-- ───────────────────────────────────────────────────────────

-- Simplified blue_in_green style progression

-- Step 1: Define harmony (4 jazz chords)
jazzHarmony = fromChordsFlat [
    [10, 2, 9, 4],    -- Bbmaj7#11
    [9, 1, 7, 10],    -- A7#9
    [2, 5, 0, 11],    -- Dm13
    [1, 5, 11, 3]     -- Db9
  ]

-- Step 2: Define scales (modal choices per chord)
jazzScales = fromChordsFlat [
    [10, 0, 2, 4, 5, 7, 9],       -- Bb Lydian
    [9, 11, 1, 3, 5, 7, 8],       -- A altered
    [2, 4, 5, 7, 9, 11, 0],       -- D Dorian
    [1, 3, 5, 6, 8, 10, 0]        -- Db Mixolydian
  ]

-- Step 3: Define melody (simple modal exploration)
jazzMelody = slow 4 $ slowcat [
    "0 2 4 2",       -- Lydian motif
    "0 3 6 3",       -- Altered tension
    "0 2 4 6",       -- Dorian ascent
    "0 -2 -4 0"      -- Mixolydian resolution
  ]

-- Step 4: Perform
do
  setbpm 60

  -- Harmony (jazz chords, flow voicing):
  d01 $ note (flow jazzHarmony "<0 1 2 3>")
        # ch 01 |* vel 0.7

  -- Melody (modal scales):
  d02 $ note (harmony jazzScales jazzMelody)
        # ch 02 |+ oct 1 |* vel 0.6

hush


-- ───────────────────────────────────────────────────────────
-- 6.7 Complete Example 3 - AABA Form
-- ───────────────────────────────────────────────────────────

-- Simplified rosslyn_castle style with form transformation

-- Step 1: Define sections

-- A section (4 chords):
aHarmony = [
    notesToPCs [C, E, G],
    notesToPCs [F, A, C],
    notesToPCs [G, B, D],
    notesToPCs [C, E, G]
  ]

aScale = [
    [0, 2, 4, 7, 9],    -- C major pentatonic
    [0, 2, 4, 5, 9],    -- F major pentatonic
    [0, 2, 4, 7, 9],    -- G major pentatonic
    [0, 2, 4, 7, 9]     -- C major pentatonic
  ]

-- B section (4 chords, contrasting):
bHarmony = [
    notesToPCs [A, C, E],
    notesToPCs [D, F', A],
    notesToPCs [G, B, D],
    notesToPCs [C, E, G]
  ]

bScale = [
    [0, 2, 3, 7, 9],    -- A minor pentatonic
    [2, 4, 6, 9, 11],   -- D major pentatonic
    [0, 2, 4, 7, 9],    -- G major pentatonic
    [0, 2, 4, 7, 9]     -- C major pentatonic
  ]

-- Step 2: Assemble AABA form (16 chords total)
aabaHarmony = concat [aHarmony, aHarmony, bHarmony, aHarmony]
aabaScale   = concat [aScale, aScale, bScale, aScale]

-- Create progressions:
formHarmony = fromChordsFlat aabaHarmony
formScale   = fromChordsFlat aabaScale

-- Step 3: Define melody (same pattern, different scales)
formMelody = slow 16 $ slowcat [
    "[0 2 4 2]*4",      -- A section motif (repeated)
    "[0 2 4 2]*4",      -- A section motif (repeated)
    "[0 3 5 3]*4",      -- B section motif (contrast)
    "[0 2 4 7]*4"       -- A section motif (resolution)
  ]

-- Step 4: Perform AABA
do
  setbpm 100

  -- Harmony (16-bar AABA):
  d01 $ note (flow formHarmony
        "<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>")
        # ch 01 |* vel 0.7

  -- Melody (follows scale changes):
  d02 $ note (harmony formScale formMelody)
        # ch 02 |+ oct 1 |* vel 0.6

hush

-- Step 5: Transform to ABAB (same sections, new order)
ababHarmony = concat [aHarmony, bHarmony, aHarmony, bHarmony]
ababScale   = concat [aScale, bScale, aScale, bScale]

formHarmony2 = fromChordsFlat ababHarmony
formScale2   = fromChordsFlat ababScale

-- Perform ABAB (same melody, different form):
do
  setbpm 100

  d01 $ note (flow formHarmony2
        "<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>")
        # ch 01 |* vel 0.7

  d02 $ note (harmony formScale2 formMelody)
        # ch 02 |+ oct 1 |* vel 0.6

hush


-- ═══════════════════════════════════════════════════════════
-- SECTION 7: ADVANCED TECHNIQUES
-- ═══════════════════════════════════════════════════════════
-- Goal: Master composer weights, contexts, and live control


-- ───────────────────────────────────────────────────────────
-- 7.1 Composer Blending
-- ───────────────────────────────────────────────────────────

-- Weight multiple composers for stylistic blends
-- Syntax: "composer1:weight composer2:weight ..."
-- Weights are normalized to sum to 1.0

let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = hContext "*" "C" "*"

-- Single composer:
prog1 <- gen start 8 "bach" 0.5 ctx

-- Equal blend (no weights):
prog2 <- gen start 8 "bach debussy" 0.5 ctx

-- Weighted blend (75% Debussy, 25% Bach):
prog3 <- gen start 8 "debussy:0.75 bach:0.25" 0.5 ctx

-- Multiple composers with weights:
prog4 <- gen start 8 "ravel:2 stravinsky:1 mozart:1" 0.5 ctx
  -- 50% Ravel, 25% Stravinsky, 25% Mozart

-- Wildcard (all composers equally):
prog5 <- gen start 8 "*" 0.5 ctx

-- Play and compare:
d01 $ note (harmony prog3 "<0 1 2 3 4 5 6 7>") # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 7.2 Custom Context Patterns
-- ───────────────────────────────────────────────────────────

-- Combine overtone, key, and root filtering for genres:

-- JAZZ CONTEXT (D major, specific roots)
let jazzCtx = hContext "*" "2#" "D F# A"
    start = initCadenceState 0 "D" [0,4,7] FlatSpelling
jazzProg <- gen start 16 "debussy ravel" 0.6 jazzCtx

d01 $ note (harmony jazzProg "<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>")
      # ch 01

hush

-- BLUES CONTEXT (F major, I-IV-V roots only)
let bluesCtx = hContext "*" "1b" "F Bb C"
    start = initCadenceState 0 "F" [0,4,7,10] FlatSpelling
bluesProg <- gen start 12 "*" 0.4 bluesCtx

d01 $ note (harmony bluesProg "<0 1 2 3 4 5 6 7 8 9 10 11>")
      # ch 01

hush

-- MODAL CONTEXT (no key filter, specific roots)
let modalCtx = hContext "*" "*" "C Eb F G Bb"
    start = initCadenceState 0 "C" [0,3,7] FlatSpelling
modalProg <- gen start 8 "debussy" 0.7 modalCtx

d01 $ note (harmony modalProg "<0 1 2 3 4 5 6 7>")
      # ch 01

hush

-- BASS-TUNED CONTEXT (overtones only, no key)
let bassCtx = hContext "E A D G" "*" "*"
    start = initCadenceState 0 "E" [0,4,7] FlatSpelling
bassProg <- gen start 8 "*" 0.5 bassCtx

d01 $ note (harmony bassProg "<0 1 2 3 4 5 6 7>")
      # ch 01

hush


-- ───────────────────────────────────────────────────────────
-- 7.3 Entropy Tuning
-- ───────────────────────────────────────────────────────────

-- Control exploration vs exploitation (0.0 - 2.5)
-- Practical range: 0.3 - 0.8
--   0.3 = very conservative (most probable paths)
--   0.5 = balanced (default)
--   0.8 = exploratory (adventurous)
--   1.0+ = highly experimental (unpredictable)

let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = hContext "*" "C" "*"

-- Conservative (entropy 0.3):
prog1 <- gen start 8 "*" 0.3 ctx
d01 $ note (harmony prog1 "<0 1 2 3 4 5 6 7>") # ch 01
hush

-- Balanced (entropy 0.5):
prog2 <- gen start 8 "*" 0.5 ctx
d01 $ note (harmony prog2 "<0 1 2 3 4 5 6 7>") # ch 01
hush

-- Exploratory (entropy 0.8):
prog3 <- gen start 8 "*" 0.8 ctx
d01 $ note (harmony prog3 "<0 1 2 3 4 5 6 7>") # ch 01
hush

-- Highly experimental (entropy 1.5):
prog4 <- gen start 8 "*" 1.5 ctx
d01 $ note (harmony prog4 "<0 1 2 3 4 5 6 7>") # ch 01
hush


-- ───────────────────────────────────────────────────────────
-- 7.4 Live Transformation Examples
-- ───────────────────────────────────────────────────────────

-- Combine techniques for live performance control:

let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = hContext "*" "C" "*"
    comp = "debussy:0.75 bach:0.25"

prog <- gen start 16 comp 0.6 ctx

-- Performance pattern with live transformations:
p01 f s r d = d01 $ do
  let o = ch 01
  f $ stack [
    silence,

    -- Chords (original):
    arrange flow s r (-9,9) ["~", "[0,1,2,3]/4"]
      # o |* vel 0.8,

    -- Bass (transposed):
    arrange root (transposeP 7 s) r (-9,9) ["~", "0*2"]
      # o |* vel 1 |- oct 2
  ] |* vel d

-- Execute with different transformations:
do
  let f = id; r = 1; d = (*0.8)
  setbpm 100

  -- Original:
  p01 f prog r $ d 0.7

  -- Rotated (shift starting position):
  p01 f (rotate 4 prog) r $ d 0.7

  -- Section only (bars 4-11):
  p01 f (excerpt 4 11 prog) r $ d 0.7

  -- Reversed with overlap:
  p01 f (progOverlapF 1 $ reverse prog) r $ d 0.7

hush


-- ═══════════════════════════════════════════════════════════
-- SECTION 8: COMPLETE PERFORMANCE TEMPLATE
-- ═══════════════════════════════════════════════════════════
-- Goal: Production-ready session structure


-- ───────────────────────────────────────────────────────────
-- 8.1 Setup and Context
-- ───────────────────────────────────────────────────────────

-- Set tempo:
setbpm 100

-- Define context (C major):
let ctx = hContext "*" "C" "*"


-- ───────────────────────────────────────────────────────────
-- 8.2 Generate Sections
-- ───────────────────────────────────────────────────────────

-- Verse (C major, conservative):
let startV = initCadenceState 0 "C" [0,4,7] FlatSpelling
verse <- gen startV 8 "*" 0.4 ctx

-- Chorus (F major, exploratory):
let startC = initCadenceState 0 "F" [0,4,7] FlatSpelling
chorus <- gen startC 8 "*" 0.6 ctx

-- Bridge (A minor, balanced):
let startB = initCadenceState 0 "A" [0,3,7] FlatSpelling
bridge <- gen startB 8 "debussy:0.75 bach:0.25" 0.5 ctx


-- ───────────────────────────────────────────────────────────
-- 8.3 Launcher Blocks
-- ───────────────────────────────────────────────────────────

-- p01: Main chords (MIDI piano)
p01 f s r d = d01 $ do
  let o = ch 01
  f $ stack [
    silence,

    -- Chords (flow voicing):
    arrange flow s r (-9,9) ["~", "[0,1,2,3]/4"]
      # o |* vel 0.8,

    -- Melody (flow voicing, high octave):
    arrange flow s r (-9,9) ["~", "[2 4 5]@3"]
      # o |* vel 0.6 |+ oct 1
  ] |* vel d

-- p02: Bass line (MIDI piano)
p02 f s r d = d02 $ do
  let o = ch 02
  f $ arrange root s r (-9,9) ["0*2"]
       # o |* vel 1 |- oct 2 |* vel d

-- p03: Arpeggios (MIDI piano)
p03 f s r d = d03 $ do
  let o = ch 03
  f $ arrange flow s r (-9,9) ["0 1 2 3 4 5 6 7"]
       # o |* vel 0.7 |* vel d


-- ───────────────────────────────────────────────────────────
-- 8.4 Performance Flow
-- ───────────────────────────────────────────────────────────

-- INTRO (verse, sparse)
do
  let f = id; r = 1; d = (*0.8)
  setbpm 90
  p01 f verse r $ d 0.5

hush

-- VERSE (full texture)
do
  let f = id; r = 1; d = (*0.8)
  setbpm 100
  p01 f verse r $ d 0.7
  p02 f verse r $ d 0.7

hush

-- CHORUS (transposed to F)
do
  let f = id; r = 1; d = (*0.8)
  setbpm 105
  p01 f (transposeP 5 chorus) r $ d 0.8
  p02 f (transposeP 5 chorus) r $ d 0.8
  p03 f (transposeP 5 chorus) r $ d 0.6

hush

-- BRIDGE (contrasting, reversed)
do
  let f = slow 2; r = 1; d = (*0.8)
  setbpm 80
  p01 f (reverse bridge) r $ d 0.7
  p02 f (reverse bridge) r $ d 0.7

hush

-- OUTRO (verse, fading)
do
  let f = id; r = 1; d = (*0.8)
  setbpm 90
  p01 f verse r $ d 0.5
  p02 f verse r $ d 0.3

hush


-- ───────────────────────────────────────────────────────────
-- 8.5 Live Improvisation Template
-- ───────────────────────────────────────────────────────────

-- Quick session with flexible control:

-- Generate one long progression:
let start = initCadenceState 0 "C" [0,4,7] FlatSpelling
    ctx = hContext "*" "C" "*"
prog <- gen start 32 "*" 0.5 ctx

-- Launcher with transformation support:
p01 f s r d = d01 $ do
  let o = ch 01
  f $ stack [
    silence,
    arrange flow s r (-9,9) ["~", "[0,1,2,3]/4"]
      # o |* vel 0.8
  ] |* vel d

-- Perform with live transformations:
do
  let f = id; r = 1; d = (*0.8)
  setbpm 100

  -- Try different sections:
  p01 f (excerpt 0 7 prog) r $ d 0.7    -- Bars 0-7
  p01 f (excerpt 8 15 prog) r $ d 0.7   -- Bars 8-15
  p01 f (excerpt 16 23 prog) r $ d 0.7  -- Bars 16-23

  -- Try transformations:
  p01 f (rotate 4 prog) r $ d 0.7       -- Rotated
  p01 f (reverse prog) r $ d 0.7        -- Reversed
  p01 f (transposeP 7 prog) r $ d 0.7   -- Transposed

hush


-- ═══════════════════════════════════════════════════════════
-- SECTION 9: QUICK REFERENCE
-- ═══════════════════════════════════════════════════════════
-- Goal: Cheatsheet for all operations


-- ───────────────────────────────────────────────────────────
-- 9.1 Generation Functions
-- ───────────────────────────────────────────────────────────

-- gen, genSilent, genStandard, genVerbose
--   :: CadenceState -> Int -> String -> Double
--   -> HarmonicContext -> IO Progression

-- initCadenceState
--   :: Int -> String -> [Int] -> EnharmonicSpelling
--   -> CadenceState

-- hContext, harmonicContext
--   :: String -> String -> String -> HarmonicContext

-- defaultContext :: HarmonicContext  (all wildcards)


-- ───────────────────────────────────────────────────────────
-- 9.2 Explicit Construction (B2)
-- ───────────────────────────────────────────────────────────

-- fromChords
--   :: EnharmonicSpelling -> [[Int]] -> Progression

-- fromChordsFlat  :: [[Int]] -> Progression
-- fromChordsSharp :: [[Int]] -> Progression

-- prog :: EnharmonicSpelling -> [[Int]] -> Progression
--   (legacy alias)

-- notesToPCs :: [NoteName] -> [Int]
--   Available: C, C', Db, D, D', Eb, E, F, F', Gb, G, G', Ab,
--              A, A', Bb, B


-- ───────────────────────────────────────────────────────────
-- 9.3 Voicing Functions
-- ───────────────────────────────────────────────────────────

-- harmony, flow :: Progression -> Pattern Int -> Pattern Int
-- root           :: Progression -> Pattern Int -> Pattern Int
-- lite           :: Progression -> Pattern Int -> Pattern Int
-- bass           :: Progression -> Pattern Int -> Pattern Int

-- voiceBy :: Voicing -> Progression
--         -> Pattern Int -> Pattern Int
--   Voicing options: Harmony, Roots, Lite, Bass


-- ───────────────────────────────────────────────────────────
-- 9.4 Transformation Functions
-- ───────────────────────────────────────────────────────────

-- rotate       :: Int -> Progression -> Progression
-- excerpt      :: Int -> Int -> Progression -> Progression
-- transposeP   :: Int -> Progression -> Progression
-- reverse      :: Progression -> Progression
-- fuse         :: Progression -> Progression -> Progression
-- expandP      :: Int -> Progression -> Progression
-- progOverlapF :: Int -> Progression -> Progression


-- ───────────────────────────────────────────────────────────
-- 9.5 Pattern Interface
-- ───────────────────────────────────────────────────────────

-- arrange :: Voicing -> Progression -> Int
--         -> (Int, Int) -> [String] -> Pattern Int
--   Voicing: flow, root, lite, bass
--   Register: (-9, 9) typical
--   Patterns: ["~", "[0,1,2,3]/4"] etc.


-- ───────────────────────────────────────────────────────────
-- 9.6 MIDI Helpers (BootTidal.hs)
-- ───────────────────────────────────────────────────────────

-- ch :: Int -> Pattern ValueMap
--   MIDI channel (ch 01, ch 02, etc.)

-- vel :: Pattern Double -> Pattern ValueMap
--   Velocity/amplitude

-- oct :: Int -> Pattern ValueMap
--   Octave shift (|+ oct 1, |- oct 2)

-- bpm :: Double -> Pattern Time
--   Tempo (deprecated, use setbpm)

-- setbpm :: Double -> IO ()
--   Set tempo (setbpm 120)


-- ───────────────────────────────────────────────────────────
-- 9.7 Common Patterns
-- ───────────────────────────────────────────────────────────

-- Play harmony:
-- d01 $ note (harmony prog "<0 1 2 3>") # ch 01

-- Bass line (root voicing, low octave):
-- d02 $ note (root prog "0*2") # ch 02 |- oct 2

-- Arpeggios (flow voicing):
-- d03 $ note (flow prog "0 1 2 3 4 5 6 7") # ch 03

-- Multi-voice stack:
-- d01 $ stack [
--   note (harmony prog "<0 1 2 3>") # ch 01,
--   note (root prog "0*2") # ch 01 |- oct 2
-- ]

-- Launcher block pattern:
-- p01 f s r d = d01 $ do
--   let o = ch 01
--   f $ arrange flow s r (-9,9) ["pattern"] # o |* vel d


-- ───────────────────────────────────────────────────────────
-- 9.8 Troubleshooting
-- ───────────────────────────────────────────────────────────

-- Neo4j not running:
--   docker compose up -d neo4j
--   curl http://localhost:7474  (verify accessible)

-- BootTidal.hs not loaded:
--   :script /path/to/BootTidal.hs  (in TidalCycles)

-- MIDI not working:
--   Check MIDI device on channel (tidal-piano on ch 01)
--   Verify SuperDirt MIDI config in SuperCollider

-- Pattern not playing:
--   Check pattern syntax (use "" for strings)
--   Verify progression index range (<0 1 2 3> for 4 chords)
--   Try hush and restart


-- ═══════════════════════════════════════════════════════════
-- END OF USER GUIDE
-- ═══════════════════════════════════════════════════════════
-- For more examples, see:
--   live/examples/blue_in_green.tidal
--   live/examples/rosslyn_castle.tidal
--   live/testTidal.tidal
--   live/studio.tidal
--
-- Documentation:
--   https://github.com/OscarSouth/theHarmonicAlgorithm
--
-- Happy composing!
