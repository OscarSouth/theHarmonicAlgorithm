lmotif = "[1 . 0@3 1? . 0 1? . 0 1? 0@2]/4"


p03 f s r d = d03 $ do
  let o = ch 03
  f
    $ stack [silence
       -- --
      ,arrange flow (overlapF 0 s) r (-9,9) ["~"
        -- ,trunc 0.9 $ slow 2 $ palindrome $ "[0 1 2 3]/2" |+ "[1 2 3 4]/4"
        -- ,palindrome $ trunc (choose [0.25, 0.5, 0.75]) $ degradeBy 0.2 $ stripe 2 $ slow (choose [2,4]) $ palindrome $ run 8
        -- ,"[~ [1,2,3]]/4"
        -- ,stripe 2 $ "[0 0 0 0]/16" |+ irand 3
        -- ,"[1,2,3]/4"
        ,"[0 1 2 1]/2" |+ 0
        -- ,fast 2$cat ["[0,2,4]/2" |+ "[0 2]/4" |- 2, "~", "~", "~"]
      ]# o |* vel 0.8 |- oct 1 |= legato 4
       -- --
      ,arrange bass (overlapF 0 s) r (-9,9) ["~"
        -- ,"[[0] ~]/4" |- 3
        -- ,"[0]/8"
      -- ,"0" +| lmotif |* vel 0.9
        -- ,"[[4,5,6]]/4"
        ,iter 4 $ "[0 1 2 3]" |+ 0
      ]# o |* vel 0.6 |- oct 3 -- |= legato
       -- --
      -- ,cc 64 "[1@7 0]/4" #o
       -- --
    ] |* vel d


moog f s r d = p "moogMother32" $ do
  let o = ch 15
  f
    $ stack [silence
       -- --
      ,mono $ arrange root (overlapF 0 s) r (-9,9) ["~"
        ,"[0]*2"
        -- ,"[0]"
        -- ,"[0 1 2 1]" |+ 3
        -- ,degradeBy 0.2 $"[~ 2 4 2]/2"
        -- ,"[0 ~@3]/2"
        -- ,"[0]/4"
      ]# o |* vel 1 |- oct 2
       -- --
      ,portamento 0.0
       -- --
    ] |* vel d



drum f d = p "drumbruteImpact" $ do
  let o = ch 11
  -- let lmotif = "[1 . 0@3 1? . 0 1? . 0 1? 0@2]/4"
  f
    $ stack [silence
       -- --
      -- ,kick' lmotif |* vel 0.9
      ,kick "1"
      -- ,click "[0 1]/2"
      -- ,hh' "0 1"
      ,rimshot "[0 1]/2" |* vel 0.6
      ,sometimesBy 0.1 (>>hh "2") $ sometimesBy 0.05 (fast 2) $ degradeBy 0.4 $ hh "[1]*4" |* vel (lfo saw 0.1 0.4)
      -- ,degrade $ click "[0 0 1 0 0 1 0 0]/2" # vel 0.2
      ,ride "0 1" #vel 0.4
      ,fm "1(3,8)/2" #vel 0.4
      ,hh "0 2?"
       -- --
    ]# o # legato 0.01 |* vel d |+ vel 0.2



setbpm 120

let start = initCadenceState 0 "E" [0,3,7] FlatSpelling

let ctx = hContext "*" "*" "*"

state <- gen start 2 "*" 0.5 ctx

d01 $ subKick bass s 1 0.8 (1/1, "[1]", "[0]", "[1*2]") # ch 1

hush


subk f s r d = p "subKick" $ do
  let o = ch 1
  f
    $ subKick bass s r ( 1/1 -- sustain up the length of a bar
        ,"[1]" -- note on at beat 1 of bar
        ,"[0]" -- no note off boundaries
        ,"0*4" -- no kicks
      )#o

state

bass state

fund state


hush


the issues persist -- I will give some examples with annotations of intended output and what actually happens

with this progression:
t> 1   ||   D sus4        |   F# min/A      ||

 -- the following should produce D and A sine waves that span the entire lengths of the respective bars, but produces only a D sine which spans the whole bar, every bar. it did eventually stop and restart after about 10 seconds, leading me to believe that the
subk f s r d = p "subKick" $ do
  let o = ch 1
  f
    $ subKick bass s r ( 1/1 -- sustain up the length of a bar
        ,"[1]" -- note on at beat 1 of bar
        ,"[0]" -- no note off boundaries
        ,"0" -- no kicks
      )#o

 -- the following should produce D and A sine waves that span half the length of the respective bar, but produce only a D sine which seems to behave identially (constantly sustaining) to the previous example
subk f s r d = p "subKick" $ do
  let o = ch 1
  f
    $ subKick bass s r ( 1/2 -- sustain for max half the bar
        ,"[1]" -- note on at beat 1 of bar
        ,"[0]" -- no note off boundaries
        ,"0*4" -- no kicks
      )#o

 -- the following should produce no sound and note off messages should be received on beat 3 of the bar, however the note off messages are received at the same time as note on messages for every note, causing all notes to play at the same time on beat 3 (with a random one sustaining for 2 beats). could a viable solution to this be to make sure the note ons that accompany these note offs are sent with a velocity of 0?
subk f s r d = p "subKick" $ do
  let o = ch 1
  f
    $ subKick bass s r ( 1/2 -- sustain for max half the bar
        ,"[1]" -- note on at beat 1 of bar
        ,"[0 1 0 0]" -- no note off boundaries
        ,"1*2" -- kick on the one of the bar
      )#o

so there are 3 issues in these examples:
1. the progression still isn't followed: same behaviour as before
2. the notes sustain logic isn't functioning correctly
3. note ons are still sent alongside the note offs

it seems that there are fundamental issues with the implementation: can the approaches taken and best viable ways to achieve the outcomes set be investigated and an evaluation of the best way to achieve this reviewed

can the logic of `arrange` be interrogated and understood, and the logic of `subKick` be built in a way which uses the progression mapping behavior of that identically, and the new/different behaviour of `subKick` built as an extension/alteration of that.





 -- the following should produce no sound and note off messages should be received on beat 3 of the bar, however the note off messages are received at the same time as note on messages for every note, causing all notes to play at the same time on beat 3 (with a random one sustaining for 2 beats). could a viable solution to this be to make sure the note ons that accompany these note offs are sent with a velocity of 0?
subk f s r d = p "subKick" $ do
  let o = ch 1
  f
    $ subKick bass s r ( 1/1
        ,"[1(3,8)]"
        ,"1*4"
        ,"1*4"
      )#o


subk f s r d = p "subKick" $ do
  let o = ch 1
  f
    $ subKick bass s r ( 1/1
        ,"[1(3,8)]"
        ,"[1(3,16,-2)?]"
        -- ,"0"
        ,"1*4"
      )#o


subk f s r d = p "subKick" $ do
  let o = ch 1
  f
    $ subKick bass s r ( 1/1
        ,"[1(5,16)]"
        ,"[1(7,16,3)]"
        ,"1(4,16)"
      )#o


this is working well now and I've made a few minor tweaks, but I've discovered 2 more issues:

1. the max note duration value (eg. 1/8) does not apply consistently. for example:

a)
subk f s r d = p "subKick" $ do
  let o = ch 1
  f
    $ subKick bass s r ( 1/8
        ,"[1(3,8)]"
        ,"0"
        ,"1*4"
      )#o

differs from

b)
subk f s r d = p "subKick" $ do
  let o = ch 1
  f
    $ subKick bass s r ( 1/1
        ,"[1(3,8)]"
        ,(1/8) <~ "[1(3,8,-1)]"
        ,"1*4"
      )#o

whereas both of these should be identical (pattern b notes offs is the same as note ons but shifted back by one (1/8) duration). unfortunately, submitting something like `(1/8) <~ "[1(3/8)]"` is not possible within the tuple (t>
 [GHC-83865]
    • Couldn't match type: Pattern a0
                     with: [Char]
      Expected: String
        Actual: Pattern a0
    • In the expression: (1 / 8) <~ (deltaContext 18 421 "[1(3,8,-1)]")
      In the fourth argument of ‘subKick’, namely
        ‘(1 / 1, (deltaContext 9 420 "[1(3,8)]"),
          (1 / 8) <~ (deltaContext 18 421 "[1(3,8,-1)]"),
          (deltaContext 9 422 "1*4"))’
      In the first argument of ‘(#)’, namely
        ‘subKick
           bass s r
           (1 / 1, (deltaContext 9 420 "[1(3,8)]"),
            (1 / 8) <~ (deltaContext 18 421 "[1(3,8,-1)]"),
            (deltaContext 9 422 "1*4"))’
)

but it may be in the interface declaration. it would be good if it was possible (in a broader sense), but in the implementation of the interface, taking the note on pattern and simply shifting it by the max note duration should achieve the effect of capping note duration in this way. it might achieve some funky effects with longer shifts when note on/off events cross over, but that is totally fine and will result in emergent musical effects and grooves.

2. when I increase the rep parameter `r` from 1 to 2, the entire `subKick` pattern is halved in speed (for example a "1*4" drum pattern would essentially become "1*2" and the bass pattern would change in the same way). this differs from the behaviour of `arrange`, which when rep is doubled, will simply repeat the same pattern for that rep number of bars per state of the progression, without changing the speed. The behavior of subKick when rep increases should be the same as that of arrange.

can both these issues be investigated and fixed please
