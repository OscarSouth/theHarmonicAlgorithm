# Project Context: global-project
Generated on: Wed 21 Jan 2026 09:39:27 GMT
Directory: /Users/oscarsouth/.stack/global-project
Depth: Unlimited (all subdirectories)

## Project Structure
```
├── app/
│   ├── Main.hs
│   └── README.md
├── boot/
│   └── BootTidal.hs
├── data/
│   └── ycacl_sequences.csv
├── live/
│   ├── CompletedTests/
│   │   ├── test_progression.tidal
│   │   ├── test_traversal.tidal
│   │   ├── test_voiceleading.tidal
│   │   └── test_voicing_paradigms.tidal
│   ├── debug/
│   │   └── debug.tidal
│   ├── examples/
│   │   ├── blue_in_green.tidal
│   │   └── rosslyn_castle.tidal
│   ├── perform/
│   │   └── state.tidal
│   ├── BootTidal.hs
│   ├── demo.tidal
│   ├── examples.tidal
│   ├── pattern_club.tidal
│   ├── state.tidal
│   ├── studio.tidal
│   ├── superdirt_startup.scd
│   ├── test.tidal
│   ├── testTidal.tidal
│   ├── testTidal0.tidal
│   └── USER_GUIDE.tidal
├── neo4j/
│   ├── data/
│   │   ├── databases/
│   │   │   ├── neo4j/
│   │   │   │   ├── schema/
│   │   │   │   │   └── index/
│   │   │   │   │       └── native-btree-1.0/
│   │   │   │   │           └── 3/
│   │   │   │   │               └── index-3
│   │   │   │   ├── database_lock
│   │   │   │   ├── neostore
│   │   │   │   ├── neostore.counts.db
│   │   │   │   ├── neostore.indexstats.db
│   │   │   │   ├── neostore.labelscanstore.db
│   │   │   │   ├── neostore.labeltokenstore.db
│   │   │   │   ├── neostore.labeltokenstore.db.id
│   │   │   │   ├── neostore.labeltokenstore.db.names
│   │   │   │   ├── neostore.labeltokenstore.db.names.id
│   │   │   │   ├── neostore.nodestore.db
│   │   │   │   ├── neostore.nodestore.db.id
│   │   │   │   ├── neostore.nodestore.db.labels
│   │   │   │   ├── neostore.nodestore.db.labels.id
│   │   │   │   ├── neostore.propertystore.db
│   │   │   │   ├── neostore.propertystore.db.arrays
│   │   │   │   ├── neostore.propertystore.db.arrays.id
│   │   │   │   ├── neostore.propertystore.db.id
│   │   │   │   ├── neostore.propertystore.db.index
│   │   │   │   ├── neostore.propertystore.db.index.id
│   │   │   │   ├── neostore.propertystore.db.index.keys
│   │   │   │   ├── neostore.propertystore.db.index.keys.id
│   │   │   │   ├── neostore.propertystore.db.strings
│   │   │   │   ├── neostore.propertystore.db.strings.id
│   │   │   │   ├── neostore.relationshipgroupstore.db
│   │   │   │   ├── neostore.relationshipgroupstore.db.id
│   │   │   │   ├── neostore.relationshipgroupstore.degrees.db
│   │   │   │   ├── neostore.relationshipstore.db
│   │   │   │   ├── neostore.relationshipstore.db.id
│   │   │   │   ├── neostore.relationshiptypescanstore.db
│   │   │   │   ├── neostore.relationshiptypestore.db
│   │   │   │   ├── neostore.relationshiptypestore.db.id
│   │   │   │   ├── neostore.relationshiptypestore.db.names
│   │   │   │   ├── neostore.relationshiptypestore.db.names.id
│   │   │   │   ├── neostore.schemastore.db
│   │   │   │   └── neostore.schemastore.db.id
│   │   │   ├── system/
│   │   │   │   ├── schema/
│   │   │   │   │   └── index/
│   │   │   │   │       └── native-btree-1.0/
│   │   │   │   │           ├── 3/
│   │   │   │   │           │   └── index-3
│   │   │   │   │           ├── 4/
│   │   │   │   │           │   └── index-4
│   │   │   │   │           └── 7/
│   │   │   │   │               └── index-7
│   │   │   │   ├── database_lock
│   │   │   │   ├── neostore
│   │   │   │   ├── neostore.counts.db
│   │   │   │   ├── neostore.indexstats.db
│   │   │   │   ├── neostore.labelscanstore.db
│   │   │   │   ├── neostore.labeltokenstore.db
│   │   │   │   ├── neostore.labeltokenstore.db.id
│   │   │   │   ├── neostore.labeltokenstore.db.names
│   │   │   │   ├── neostore.labeltokenstore.db.names.id
│   │   │   │   ├── neostore.nodestore.db
│   │   │   │   ├── neostore.nodestore.db.id
│   │   │   │   ├── neostore.nodestore.db.labels
│   │   │   │   ├── neostore.nodestore.db.labels.id
│   │   │   │   ├── neostore.propertystore.db
│   │   │   │   ├── neostore.propertystore.db.arrays
│   │   │   │   ├── neostore.propertystore.db.arrays.id
│   │   │   │   ├── neostore.propertystore.db.id
│   │   │   │   ├── neostore.propertystore.db.index
│   │   │   │   ├── neostore.propertystore.db.index.id
│   │   │   │   ├── neostore.propertystore.db.index.keys
│   │   │   │   ├── neostore.propertystore.db.index.keys.id
│   │   │   │   ├── neostore.propertystore.db.strings
│   │   │   │   ├── neostore.propertystore.db.strings.id
│   │   │   │   ├── neostore.relationshipgroupstore.db
│   │   │   │   ├── neostore.relationshipgroupstore.db.id
│   │   │   │   ├── neostore.relationshipgroupstore.degrees.db
│   │   │   │   ├── neostore.relationshipstore.db
│   │   │   │   ├── neostore.relationshipstore.db.id
│   │   │   │   ├── neostore.relationshiptypescanstore.db
│   │   │   │   ├── neostore.relationshiptypestore.db
│   │   │   │   ├── neostore.relationshiptypestore.db.id
│   │   │   │   ├── neostore.relationshiptypestore.db.names
│   │   │   │   ├── neostore.relationshiptypestore.db.names.id
│   │   │   │   ├── neostore.schemastore.db
│   │   │   │   └── neostore.schemastore.db.id
│   │   │   └── store_lock
│   │   ├── dbms/
│   │   │   └── auth.ini
│   │   ├── transactions/
│   │   │   ├── neo4j/
│   │   │   │   ├── checkpoint.0
│   │   │   │   ├── neostore.transaction.db.4
│   │   │   │   └── neostore.transaction.db.5
│   │   │   └── system/
│   │   │       ├── checkpoint.0
│   │   │       └── neostore.transaction.db.0
│   │   └── server_id
│   └── plugins/
│       └── apoc.jar
├── scripts/
│   ├── export_ycacl.R
│   └── README.md
├── src/
│   ├── Core/
│   ├── Database/
│   ├── Harmonic/
│   │   ├── Analysis/
│   │   ├── Core/
│   │   ├── Database/
│   │   ├── Evaluation/
│   │   │   ├── Analysis/
│   │   │   │   └── Markov.hs
│   │   │   ├── Database/
│   │   │   │   └── Query.hs
│   │   │   └── Scoring/
│   │   │       ├── Dissonance.hs
│   │   │       └── VoiceLeading.hs
│   │   ├── Framework/
│   │   │   └── Builder.hs
│   │   ├── Ingestion/
│   │   │   └── README.md
│   │   ├── Interface/
│   │   │   ├── Patterns/
│   │   │   └── Tidal/
│   │   │       ├── Arranger.hs
│   │   │       ├── Bridge.hs
│   │   │       ├── Instruments.hs
│   │   │       └── Utils.hs
│   │   ├── Rules/
│   │   │   ├── Constraints/
│   │   │   │   ├── Filter.hs
│   │   │   │   └── Overtone.hs
│   │   │   ├── Import/
│   │   │   │   ├── CSV.hs
│   │   │   │   ├── Graph.hs
│   │   │   │   ├── Transform.hs
│   │   │   │   └── Types.hs
│   │   │   └── Types/
│   │   │       ├── Harmony.hs
│   │   │       ├── Pitch.hs
│   │   │       └── Progression.hs
│   │   ├── Tidal/
│   │   ├── Traversal/
│   │   │   └── Probabilistic.hs
│   │   ├── Config.hs
│   │   └── Lib.hs
│   ├── Ingestion/
│   └── Tidal/
├── test/
│   ├── Harmonic/
│   │   ├── Core/
│   │   ├── Database/
│   │   ├── Evaluation/
│   │   │   ├── Database/
│   │   │   │   └── QuerySpec.hs
│   │   │   └── Scoring/
│   │   │       ├── DissonanceSpec.hs
│   │   │       └── VoiceLeadingSpec.hs
│   │   ├── Framework/
│   │   │   └── BuilderSpec.hs
│   │   ├── Interface/
│   │   │   └── Tidal/
│   │   │       └── BridgeSpec.hs
│   │   ├── Rules/
│   │   │   ├── Constraints/
│   │   │   │   ├── FilterSpec.hs
│   │   │   │   └── OvertoneSpec.hs
│   │   │   └── Types/
│   │   │       ├── HarmonySpec.hs
│   │   │       ├── PitchSpec.hs
│   │   │       └── ProgressionSpec.hs
│   │   ├── Tidal/
│   │   └── Traversal/
│   │       └── ProbabilisticSpec.hs
│   └── Spec.hs
├── theHarmonicAlgorithmLegacy/
│   ├── analysis/
│   │   └── pentatonic_experiment.txt
│   ├── app/
│   │   └── Main.hs
│   ├── data/
│   │   └── jsbach_chorals_harmony.data
│   ├── documents/
│   │   ├── Data_Science_In_The_Creative_Process_2018.pdf
│   │   ├── EADG.pdf
│   │   ├── EAeGb.pdf
│   │   ├── EAeGC.pdf
│   │   ├── Harmonic_Algorithm_Reflections_2016.pdf
│   │   └── The_Harmonic_Algorithm_2016.pdf
│   ├── graphdb/
│   │   ├── dev.cql
│   │   └── test.cql
│   ├── img/
│   │   ├── choicefour.gif
│   │   ├── choiceone.gif
│   │   ├── choicethree.gif
│   │   ├── choicetwo.gif
│   │   ├── enharm.gif
│   │   ├── filterbass.gif
│   │   ├── filterkey.gif
│   │   ├── filternone.gif
│   │   ├── header.png
│   │   ├── loading.png
│   │   ├── loadingtitle.gif
│   │   ├── openfilters.gif
│   │   ├── resolve.gif
│   │   ├── selections.gif
│   │   ├── sequence.gif
│   │   └── title.png
│   ├── live/
│   │   ├── explore/
│   │   │   └── test.tidal
│   │   ├── grooves/
│   │   │   ├── hiphop.tidal
│   │   │   ├── house.tidal
│   │   │   └── jazz.tidal
│   │   ├── iter_1_tracks/
│   │   │   ├── 01-generativeA.tidal
│   │   │   ├── 02-droneA.tidal
│   │   │   ├── 03-blueInGreen.tidal
│   │   │   ├── 04-1581.tidal
│   │   │   ├── 05-droneB.tidal
│   │   │   └── 06-generativeB.tidal
│   │   ├── perform/
│   │   │   ├── orchestrate.tidal
│   │   │   └── state.tidal
│   │   ├── tracks/
│   │   │   ├── 00-tuning.tidal
│   │   │   ├── 01-harmonicAlgorithm.tidal
│   │   │   ├── 02-kulukSahyl.tidal
│   │   │   ├── 03-northernDrone.tidal
│   │   │   ├── 04-blueInGreen.tidal
│   │   │   └── 05-1581.tidal
│   │   ├── BootTidal.hs
│   │   ├── init.tidal
│   │   └── superdirt_startup.scd
│   ├── liveArchives/
│   │   ├── alpaca/
│   │   │   ├── grooves/
│   │   │   │   ├── hiphop.tidal
│   │   │   │   ├── house.tidal
│   │   │   │   └── jazz.tidal
│   │   │   ├── iter_1_tracks/
│   │   │   │   ├── 01-generativeA.tidal
│   │   │   │   ├── 02-droneA.tidal
│   │   │   │   ├── 03-blueInGreen.tidal
│   │   │   │   ├── 04-1581.tidal
│   │   │   │   ├── 05-droneB.tidal
│   │   │   │   └── 06-generativeB.tidal
│   │   │   └── tracks/
│   │   │       ├── 00-tuning.tidal
│   │   │       ├── 01-harmonicAlgorithm.tidal
│   │   │       ├── 02-kulukSahyl.tidal
│   │   │       ├── 03-northernDrone.tidal
│   │   │       ├── 04-blueInGreen.tidal
│   │   │       └── 05-1581.tidal
│   │   ├── develop/
│   │   │   ├── instruments/
│   │   │   │   ├── 1_rise_qnex.tidal
│   │   │   │   ├── 10_kmpc.tidal
│   │   │   │   ├── 11_dfo1.tidal
│   │   │   │   ├── 12_dfo2.tidal
│   │   │   │   ├── 13_dftr.tidal
│   │   │   │   ├── 14_moog.tidal
│   │   │   │   ├── 15_aira.tidal
│   │   │   │   ├── 16_juno.tidal
│   │   │   │   ├── 2_sine.tidal
│   │   │   │   ├── 3_jazz.tidal
│   │   │   │   ├── 4_smpl.tidal
│   │   │   │   ├── 5_boel.tidal
│   │   │   │   ├── 6_boeh.tidal
│   │   │   │   ├── 7_hmnx.tidal
│   │   │   │   ├── 8_d303.tidal
│   │   │   │   ├── 9_k909.tidal
│   │   │   │   └── jam1.tidal
│   │   │   ├── bg_dev.tidal
│   │   │   ├── bg_dev0.tidal
│   │   │   ├── blockNames.tidal
│   │   │   ├── blue_in_green.tidal
│   │   │   ├── blue_in_green0.tidal
│   │   │   ├── improv.tidal
│   │   │   ├── jamB.tidal
│   │   │   ├── kuluk_sahyl.tidal
│   │   │   ├── rosslyn_castle.tidal
│   │   │   ├── rosslyn_castle0.tidal
│   │   │   ├── snippets_dev.tidal
│   │   │   ├── snowfox.tidal
│   │   │   ├── syyia_tyyrdy.tidal
│   │   │   └── tech.txt
│   │   ├── edit_alpaca/
│   │   │   ├── grooves/
│   │   │   │   ├── hiphop.tidal
│   │   │   │   ├── house.tidal
│   │   │   │   └── jazz.tidal
│   │   │   ├── iter_1_tracks/
│   │   │   │   ├── 01-generativeA.tidal
│   │   │   │   ├── 02-droneA.tidal
│   │   │   │   ├── 03-blueInGreen.tidal
│   │   │   │   ├── 04-1581.tidal
│   │   │   │   ├── 05-droneB.tidal
│   │   │   │   └── 06-generativeB.tidal
│   │   │   └── tracks/
│   │   │       ├── 00-tuning.tidal
│   │   │       ├── 01-harmonicAlgorithm.tidal
│   │   │       ├── 02-kulukSahyl.tidal
│   │   │       ├── 03-northernDrone.tidal
│   │   │       ├── 04-blueInGreen.tidal
│   │   │       └── 05-1581.tidal
│   │   ├── explore/
│   │   │   ├── 0.tidal
│   │   │   ├── 1.tidal
│   │   │   ├── 2.tidal
│   │   │   ├── 3.tidal
│   │   │   ├── 4.tidal
│   │   │   ├── 5.tidal
│   │   │   ├── 6.tidal
│   │   │   ├── 7.tidal
│   │   │   ├── 8.tidal
│   │   │   ├── 80.tidal
│   │   │   ├── instruments.tidal
│   │   │   ├── jv0.tidal
│   │   │   ├── rhythms.tidal
│   │   │   ├── s1-params.tidal
│   │   │   └── StrasbourgStDenis.tidal
│   │   ├── perform/
│   │   │   ├── orchestrate.tidal
│   │   │   └── state.tidal
│   │   ├── snippets/
│   │   │   ├── alpaca_snippets.cson
│   │   │   └── snippets.cson
│   │   ├── BootTidal.hs
│   │   └── superdirt_startup.scd
│   ├── scripts/
│   │   └── import.R
│   ├── src/
│   │   ├── Analysis.hs
│   │   ├── Arranger.hs
│   │   ├── GraphDB.hs
│   │   ├── Lib.hs
│   │   ├── Markov.hs
│   │   ├── MusicData.hs
│   │   ├── Overtone.hs
│   │   └── Utility.hs
│   ├── temp/
│   │   ├── test_1.txt
│   │   ├── test_2.txt
│   │   └── test_3.txt
│   ├── test/
│   │   └── Spec.hs
│   ├── _stack.yaml
│   ├── ChangeLog.md
│   ├── docker-compose.yml
│   ├── LICENSE
│   ├── package.yaml
│   ├── README.md
│   ├── Setup.hs
│   ├── stack.yaml
│   ├── stack.yaml.bak
│   ├── stack.yaml.lock
│   ├── test_legacy.hs
│   └── theHarmonicAlgorithm.cabal
├── ARCHITECTURE.md
├── CLAUDE.md
├── docker-compose.yml
├── IMPROVEMENTS.md
├── LEGACY.md
├── notes
├── package.yaml
├── README.md
├── stack.yaml
├── stack.yaml.lock
├── test_dmajor_filter.hs
├── theHarmonicAlgorithm.cabal
└── USER_GUIDE.md
```

## File Contents

### ./app/Main.hs

```
{-# LANGUAGE OverloadedStrings #-}

module Main where

import           Harmonic.Config
import           Harmonic.Rules.Import.Graph
import           Harmonic.Rules.Import.CSV
import           Harmonic.Rules.Import.Transform
import           Harmonic.Rules.Import.Types
import qualified Harmonic.Rules.Types.Harmony as H
import qualified Harmonic.Rules.Types.Pitch as P

import qualified Database.Bolt as Bolt
import           Control.Monad (forM_)
import qualified Data.Map.Strict as Map
import           Data.Map.Strict (Map)
import qualified Data.Text as T
import           Data.Text (Text)
import           Data.Char (isAlphaNum)
import           Data.List (foldl')

type ComposerPieces = Map Text (Map Text [ChordSlice])

-- Local type alias for H.Cadence-based edges (replacing Markov.Edge which uses MD.Cadence)
type HEdge = (H.Cadence, H.Cadence)

composerInclude :: [Text]
composerInclude =
  [ "bach" -- Bach
  , "debussy" -- Debussy
  , "stravinsky" -- Stravinsky
  , "abel" -- Abel
  , "accolay" -- Accolay
  , "adam" -- Adam
  , "agnesi" -- Agnesi
  , "aguado" -- Aguado
  , "ahlefeldt" -- Ahlefeldt
  , "albeniz" -- Albeniz
  , "albinoni" -- Albinoni
  , "albrechtsberger" -- Albrechtsberger
  , "alexandrov" -- Alexandrov
  , "alkan" -- Alkan
  , "ambroise" -- Ambroise
  , "andersen" -- Andersen
  , "annaamalia" -- Anna Amalia
  , "anonymous" -- Anonymous
  , "archer" -- Archer
  , "arensky" -- Arensky
  , "arne" -- Arne
  , "arnold" -- Arnold
  , "arriaga" -- Arriaga
  , "arrieta" -- Arrieta
  , "ascher" -- Ascher
  , "astorga" -- Astorga
  , "attwood" -- Attwood
  , "auber" -- Auber
  , "audran" -- Audran
  , "bachman" -- Bachman
  , "badarzewska" -- Badarzewska
  , "balakirev" -- Balakirev
  , "balfe" -- Balfe
  , "banister" -- Banister
  , "barbieri" -- Barbieri
  , "bargiel" -- Bargiel
  , "bargy" -- Bargy
  , "barnard" -- Barnard
  , "barnett" -- Barnett
  , "baron" -- Baron
  , "barret" -- Barret
  , "barrios" -- Barrios
  , "bartok" -- Bartok
  , "bayreuth" -- Bayreuth
  , "bazin" -- Bazin
  , "bazzini" -- Bazzini
  , "beethoven" -- Beethoven
  , "bellini" -- Bellini
  , "bellinzani" -- Bellinzani
  , "bellman" -- Bellman
  , "bembo" -- Bembo
  , "benda" -- Benda
  , "benoit" -- Benoit
  , "berens" -- Berens
  , "berlioz" -- Berlioz
  , "berthelemy" -- Berthelemy
  , "berthomieu" -- Berthomieu
  , "berwald" -- Berwald
  , "best" -- Best
  , "bevilacqua" -- Bevilacqua
  , "billema" -- Billema
  , "billi" -- Billi
  , "billings" -- Billings
  , "bizet" -- Bizet
  , "blavet" -- Blavet
  , "bloch" -- Bloch
  , "blodek" -- Blodek
  , "blow" -- Blow
  , "boccherini" -- Boccherini
  , "bochsa" -- Bochsa
  , "boehm" -- Boehm
  , "boellmann" -- Boellmann
  , "boely" -- Boely
  , "bohm" -- Bohm
  , "boieldieu" -- Boieldieu
  , "boismortier" -- Boismortier
  , "bondivenezia" -- Bon Di Venezia
  , "bonis" -- Bonis
  , "borodin" -- Borodin
  , "bortnyansky" -- Bortnyansky
  , "bouffil" -- Bouffil
  , "boulanger" -- Boulanger
  , "bourgaultducoudray" -- Bourgault-Ducoudray
  , "boyce" -- Boyce
  , "braga" -- Braga
  , "braham" -- Braham
  , "brahms" -- Brahms
  , "brant" -- Brant
  , "braunschweig" -- Braunschweig
  , "brenton" -- Brenton
  , "brescianello" -- Brescianello
  , "broca" -- Broca
  , "bruch" -- Bruch
  , "bruckner" -- Bruckner
  , "bruhns" -- Bruhns
  , "burgmuller" -- Burgmuller
  , "busoni" -- Busoni
  , "buxtehude" -- Buxtehude
  , "byrd" -- Byrd
  , "cabanilles" -- Cabanilles
  , "caldara" -- Caldara
  , "campion" -- Campion
  , "campra" -- Campra
  , "cano" -- Cano
  , "cantallos" -- Cantallos
  , "carcassi" -- Carcassi
  , "cardillo" -- Cardillo
  , "carey" -- Carey
  , "carissimi" -- Carissimi
  , "carr" -- Carr
  , "carreno" -- Carreno
  , "carulli" -- Carulli
  , "casadesus" -- Casadesus
  , "casanovas" -- Casanovas
  , "casciolini" -- Casciolini
  , "casella" -- Casella
  , "castello" -- Castello
  , "catel" -- Catel
  , "cernohorsky" -- Cernohorsky
  , "cervantes" -- Cervantes
  , "chabrier" -- Chabrier
  , "chambonnieres" -- Chambonnieres
  , "chaminade" -- Chaminade
  , "chapi" -- Chapi
  , "charpentier" -- Charpentier
  , "cherubini" -- Cherubini
  , "chopin" -- Chopin
  , "chuecayrobles" -- Chueca y Robles
  , "chdeville" -- Ch_deville
  , "ciardi" -- Ciardi
  , "cilea" -- Cilea
  , "cimarosa" -- Cimarosa
  , "clarke" -- Clarke
  , "clementi" -- Clementi
  , "clerambault" -- Clerambault
  , "coleridgetaylor" -- Coleridge-Taylor
  , "colkin" -- Colkin
  , "cons" -- Cons
  , "cooke" -- Cooke
  , "corbetta" -- Corbetta
  , "corelli" -- Corelli
  , "coste" -- Coste
  , "couperin" -- Couperin
  , "cpebach" -- CPEBach
  , "cramer" -- Cramer
  , "croft" -- Croft
  , "crusell" -- Crusell
  , "cui" -- Cui
  , "czerny" -- Czerny
  , "czibulka" -- Czibulka
  , "dacosta" -- Da Costa
  , "dandrieu" -- Dandrieu
  , "daquin" -- Daquin
  , "daragona" -- DAragona
  , "dargomizhsky" -- Dargomizhsky
  , "dauprat" -- Dauprat
  , "dawes" -- Dawes
  , "dediesbach" -- De Diesbach
  , "defalla" -- De Falla
  , "dekoven" -- De Koven
  , "demacque" -- De Macque
  , "devilbac" -- De Vilbac
  , "debali" -- Debali
  , "delgadopalacios" -- Delgado Palacios
  , "delibes" -- Delibes
  , "delioux" -- Delioux
  , "delius" -- Delius
  , "demersseman" -- Demersseman
  , "dentella" -- Dentella
  , "denza" -- Denza
  , "devienne" -- Devienne
  , "diabelli" -- Diabelli
  , "dittersdorf" -- Dittersdorf
  , "donizetti" -- Donizetti
  , "doppler" -- Doppler
  , "dornell" -- Dornell
  , "draeseke" -- Draeseke
  , "dreyshock" -- Dreyshock
  , "dukas" -- Dukas
  , "duparc" -- Duparc
  , "dupre" -- Dupre
  , "durand" -- Durand
  , "durango" -- Durango
  , "durante" -- Durante
  , "dusek" -- Dusek
  , "duval" -- Duval
  , "duvernoy" -- Duvernoy
  , "dvorak" -- Dvorak
  , "eberlin" -- Eberlin
  , "eberling" -- Eberling
  , "eccles" -- Eccles
  , "eichner" -- Eichner
  , "elgar" -- Elgar
  , "enescu" -- Enescu
  , "erkel" -- Erkel
  , "ewald" -- Ewald
  , "exaudet" -- Exaudet
  , "fasch" -- Fasch
  , "faure" -- Faure
  , "ferrer" -- Ferrer
  , "fibich" -- Fibich
  , "field" -- Field
  , "finger" -- Finger
  , "fiocco" -- Fiocco
  , "fiorillo" -- Fiorillo
  , "fischer" -- Fischer
  , "fisher" -- Fisher
  , "flies" -- Flies
  , "fomin" -- Fomin
  , "franck" -- Franck
  , "frederickiithegreat" -- Frederick II the Great
  , "freixanet" -- Freixanet
  , "friese" -- Friese
  , "froberger" -- Froberger
  , "fucik" -- Fucik
  , "fux" -- Fux
  , "gade" -- Gade
  , "galliard" -- Galliard
  , "galuppi" -- Galuppi
  , "ganne" -- Ganne
  , "gaultier" -- Gaultier
  , "gelinek" -- Gelinek
  , "geminiani" -- Geminiani
  , "geoffroy" -- Geoffroy
  , "german" -- German
  , "gershwin" -- Gershwin
  , "giardini" -- Giardini
  , "gibbons" -- Gibbons
  , "gibel" -- Gibel
  , "gigout" -- Gigout
  , "gimenez" -- Gimenez
  , "giordani" -- Giordani
  , "giuliani" -- Giuliani
  , "glazunov" -- Glazunov
  , "gliere" -- Gliere
  , "glinka" -- Glinka
  , "gluck" -- Gluck
  , "godard" -- Godard
  , "godowsky" -- Godowsky
  , "haberbier" -- Haberbier
  , "haeffner" -- Haeffner
  , "hahn" -- Hahn
  , "halevy" -- Halevy
  , "halvorsen" -- Halvorsen
  , "handel" -- Handel
  , "hanon" -- Hanon
  , "haslinger" -- Haslinger
  , "hasse" -- Hasse
  , "haydn" -- Haydn
  , "hbach" -- HBach
  , "heller" -- Heller
  , "heller" -- heller
  , "henselt" -- Henselt
  , "herbert" -- Herbert
  , "herold" -- Herold
  , "herz" -- Herz
  , "hewitt" -- Hewitt
  , "hindemith" -- Hindemith
  , "hoffmeister" -- Hoffmeister
  , "hol" -- Hol
  , "holcombe" -- Holcombe
  , "holst" -- Holst
  , "hough" -- Hough
  , "huber" -- Huber
  , "hummel" -- Hummel
  , "humperdinck" -- Humperdinck
  , "hunten" -- Hunten
  , "ilynsky" -- Ilynsky
  , "ives" -- Ives
  , "jhofmann" -- J. Hofmann
  , "jmhaydn" -- J.M.Haydn
  , "jackson" -- Jackson
  , "jacquetdelaguerre" -- Jacquet de la Guerre
  , "jadassohn" -- Jadassohn
  , "jcbach" -- JCBach
  , "jensen" -- Jensen
  , "joncieres" -- Joncieres
  , "joplin" -- Joplin
  , "joseffy" -- Joseffy
  , "jullien" -- Jullien
  , "juon" -- Juon
  , "kalkbrenner" -- Kalkbrenner
  , "kelerbela" -- KelerBela
  , "kerll" -- Kerll
  , "kessler" -- Kessler
  , "ketelbey" -- Ketelbey
  , "ketterer" -- Ketterer
  , "khachaturian" -- Khachaturian
  , "kiel" -- Kiel
  , "kircher" -- Kircher
  , "kirkpatrick" -- Kirkpatrick
  , "klendel" -- Klendel
  , "kodaly" -- Kodaly
  , "komarowski" -- Komarowski
  , "kopylov" -- Kopylov
  , "koschat" -- Koschat
  , "kowalski" -- Kowalski
  , "krafft" -- Krafft
  , "kraus" -- Kraus
  , "kreisler" -- Kreisler
  , "kreutzer" -- Kreutzer
  , "krieger" -- Krieger
  , "krommer" -- Krommer
  , "krov" -- Krov
  , "kuhlau" -- Kuhlau
  , "kuhnau" -- Kuhnau
  , "kunzen" -- Kunzen
  , "lhofmann" -- L. Hofmann
  , "labitzky" -- Labitzky
  , "lachner" -- Lachner
  , "lacombe" -- Lacombe
  , "lajarte" -- Lajarte
  , "lalo" -- Lalo
  , "lassen" -- Lassen
  , "lauffensteiner" -- Lauffensteiner
  , "lawes" -- Lawes
  , "leclair" -- Leclair
  , "lecuona" -- Lecuona
  , "lefebure" -- Lefebure
  , "lefebvre" -- Lefebvre
  , "legnani" -- Legnani
  , "lehar" -- Lehar
  , "lemire" -- Lemire
  , "lemmens" -- Lemmens
  , "leo" -- Leo
  , "leonarda" -- Leonarda
  , "leschetizky" -- Leschetizky
  , "levy" -- Levy
  , "leybach" -- Leybach
  , "liguori" -- Liguori
  , "lindberg" -- Lindberg
  , "linley" -- Linley
  , "liobet" -- Liobet
  , "liszt" -- Liszt
  , "lobo" -- Lobo
  , "loeillet" -- Loeillet
  , "lori" -- Lori
  , "losy" -- Losy
  , "lotti" -- Lotti
  , "loud" -- Loud
  , "luigini" -- Luigini
  , "lully" -- Lully
  , "lyadov" -- Lyadov
  , "lyssenko" -- Lyssenko
  , "ma" -- Ma
  , "maccunn" -- Maccunn
  , "macdowell" -- Macdowell
  , "magnani" -- Magnani
  , "mahler" -- Mahler
  , "malats" -- Malats
  , "mancinelli" -- Mancinelli
  , "manfredini" -- Manfredini
  , "marais" -- Marais
  , "marcello" -- Marcello
  , "marchand" -- Marchand
  , "marpurg" -- Marpurg
  , "martin" -- Martin
  , "martini" -- Martini
  , "mascagni" -- Mascagni
  , "masse" -- Masse
  , "massenet" -- Massenet
  , "mattheson" -- Mattheson
  , "mcgranahan" -- McGranahan
  , "mehul" -- Mehul
  , "meirelez" -- Meirelez
  , "mencken" -- Mencken
  , "mendelssohn" -- Mendelssohn
  , "mercadante" -- Mercadante
  , "mertz" -- Mertz
  , "meyerbeer" -- Meyerbeer
  , "michaelis" -- Michaelis
  , "milhaud" -- Milhaud
  , "millocker" -- Millocker
  , "molina" -- Molina
  , "molique" -- Molique
  , "moncayo" -- Moncayo
  , "monckton" -- Monckton
  , "moniuszko" -- Moniuszko
  , "monn" -- Monn
  , "monti" -- Monti
  , "moretti" -- Moretti
  , "moscheles" -- Moscheles
  , "mosonyi" -- Mosonyi
  , "moszkowski" -- Moszkowski
  , "moulinie" -- Moulinie
  , "mouret" -- Mouret
  , "mozart" -- Mozart
  , "mussorgsky" -- Mussorgsky
  , "myaskovsky" -- Myaskovsky
  , "naderman" -- Naderman
  , "nascimbeni" -- Nascimbeni
  , "nazareth" -- Nazareth
  , "nebrablasco" -- Nebra Blasco
  , "nedbal" -- Nedbal
  , "nicolai" -- Nicolai
  , "nicolini" -- Nicolini
  , "nielsen" -- Nielsen
  , "novacek" -- Novacek
  , "nunesgarcia" -- Nunes Garcia
  , "ocarolan" -- Ocarolan
  , "offenbach" -- Offenbach
  , "oliveira" -- Oliveira
  , "onslow" -- Onslow
  , "pachelbel" -- Pachelbel
  , "pacini" -- Pacini
  , "paderewski" -- Paderewski
  , "paganini" -- Paganini
  , "paisiello" -- Paisiello
  , "paradis" -- Paradis
  , "paradisi" -- Paradisi
  , "parker" -- Parker
  , "parry" -- Parry
  , "pasquini" -- Pasquini
  , "pergolesi" -- Pergolesi
  , "perosi" -- Perosi
  , "persichetti" -- Persichetti
  , "pescetti" -- Pescetti
  , "peter" -- Peter
  , "petersonberger" -- Peterson-Berger
  , "pieczonka" -- Pieczonka
  , "pierpont" -- Pierpont
  , "pixis" -- Pixis
  , "platti" -- Platti
  , "pleyel" -- Pleyel
  , "ponce" -- Ponce
  , "ponchielli" -- Ponchielli
  , "poole" -- Poole
  , "popp" -- Popp
  , "poulenc" -- Poulenc
  , "prokofiev" -- Prokofiev
  , "prudent" -- Prudent
  , "pryor" -- Pryor
  , "puccini" -- Puccini
  , "purcell" -- Purcell
  , "quantz" -- Quantz
  , "quidant" -- Quidant
  , "quilter" -- Quilter
  , "rachmaninov" -- Rachmaninov
  , "raff" -- Raff
  , "rameau" -- Rameau
  , "rance" -- Rance
  , "ravel" -- Ravel
  , "ravina" -- Ravina
  , "redmer" -- Redmer
  , "reger" -- Reger
  , "reicha" -- Reicha
  , "reinecke" -- Reinecke
  , "respighi" -- Respighi
  , "reubke" -- Reubke
  , "rheinberger" -- Rheinberger
  , "rieding" -- Rieding
  , "rietz" -- Rietz
  , "rimskykorsakov" -- Rimsky-Korsakov
  , "rinaldi" -- Rinaldi
  , "riveking" -- Rive-King
  , "rodriges" -- Rodriges
  , "rodriguez" -- Rodriguez
  , "roman" -- Roman
  , "romberg" -- Romberg
  , "roncalli" -- Roncalli
  , "rosas" -- Rosas
  , "rossini" -- Rossini
  , "rubinstein" -- Rubinstein
  , "saintluc" -- Saint-Luc
  , "saintsaens" -- Saint-Saens
  , "salieri" -- Salieri
  , "sambucetti" -- Sambucetti
  , "sammartini" -- Sammartini
  , "sanz" -- Sanz
  , "sarasate" -- Sarasate
  , "satie" -- Satie
  , "scarlatti" -- Scarlatti
  , "scharwenka" -- Scharwenka
  , "scheidler" -- Scheidler
  , "schenker" -- Schenker
  , "schmelzer" -- Schmelzer
  , "scholtz" -- Scholtz
  , "schreiner" -- Schreiner
  , "schubert" -- Schubert
  , "schubertfrancios" -- SchubertFrancios
  , "schulhoff" -- Schulhoff
  , "schulz" -- Schulz
  , "schumann" -- Schumann
  , "scott" -- Scott
  , "scriabin" -- Scriabin
  , "seixas" -- Seixas
  , "serrano" -- Serrano
  , "sgambati" -- Sgambati
  , "shand" -- Shand
  , "shostakovich" -- Shostakovich
  , "sibelius" -- Sibelius
  , "sibencanin" -- Sibencanin
  , "sinding" -- Sinding
  , "smart" -- Smart
  , "smetana" -- Smetana
  , "smith" -- Smith
  , "sokolov" -- Sokolov
  , "soler" -- Soler
  , "somis" -- Somis
  , "sor" -- Sor
  , "sousa" -- Sousa
  , "souza" -- Souza
  , "spindler" -- Spindler
  , "spohr" -- Spohr
  , "stainer" -- Stainer
  , "stamitz" -- Stamitz
  , "stanely" -- Stanely
  , "stanford" -- Stanford
  , "steemson" -- Steemson
  , "steffani" -- Steffani
  , "steiner" -- Steiner
  , "strauss" -- Strauss
  , "straussi" -- Strauss I
  , "straussii" -- Strauss II
  , "strozzi" -- Strozzi
  , "sullivan" -- Sullivan
  , "suppe" -- Suppe
  , "taffanel" -- Taffanel
  , "taki" -- Taki
  , "talexy" -- Talexy
  , "tallard" -- Tallard
  , "tarrega" -- Tarrega
  , "tartini" -- Tartini
  , "tchaikovsky" -- Tchaikovsky
  , "tchesnokov" -- Tchesnokov
  , "telemann" -- Telemann
  , "thalberg" -- Thalberg
  , "thomas" -- Thomas
  , "torelli" -- Torelli
  , "translateur" -- Translateur
  , "tulou" -- Tulou
  , "turk" -- Turk
  , "umlauf" -- Umlauf
  , "vanhal" -- Vanhal
  , "vaughanwilliams" -- Vaughan Williams
  , "veracini" -- Veracini
  , "verdi" -- Verdi
  , "vierne" -- Vierne
  , "villalobos" -- Villa-Lobos
  , "vinci" -- Vinci
  , "viraldini" -- Viraldini
  , "visee" -- Visee
  , "vitali" -- Vitali
  , "vivaldi" -- Vivaldi
  , "vonbeliczay" -- Von Beliczay
  , "wagenseil" -- Wagenseil
  , "wagner" -- Wagner
  , "walckiers" -- Walckiers
  , "waldteufel" -- Waldteufel
  , "walker" -- Walker
  , "walthew" -- Walthew
  , "walton" -- Walton
  , "weber" -- Weber
  , "weckmann" -- Weckmann
  , "weiss" -- Weiss
  , "wesley" -- Wesley
  , "wfbach" -- WFBach
  , "whitaker" -- Whitaker
  , "widor" -- Widor
  , "wieniawski" -- Wieniawski
  , "wildman" -- Wildman
  , "willis" -- Willis
  , "witt" -- Witt
  , "wolf" -- Wolf
  , "wolff" -- Wolff
  , "woodcock" -- WoodCock
  , "xavier" -- Xavier
  , "yeatman" -- Yeatman
  , "yost" -- Yost
  , "yradier" -- Yradier
  , "zach" -- Zach
  , "zenetti" -- Zenetti
  , "zilcher" -- Zilcher
  , "zimmermann" -- Zimmermann
  , "zipoli" -- Zipoli
  ]

composerExclude :: [Text]
composerExclude = []

main :: IO ()
main = do
  putStrLn "theHarmonicAlgorithm: Populating Neo4j graph from YCACL artifact"
  dataset <- loadYCACLData ycaclArtifactPath
  let normalized      = normalizeComposers dataset
      activeComposers = filterComposers normalized
  putStrLn $ "Active composers: " ++ show (Map.size activeComposers)
  putStrLn "Raw YCACL coverage by composer:"
  logRawComposerStats activeComposers

  putStrLn "Deriving cadence sets per composer:"
  -- Map every composer's catalog into the duplicated cadence stream. Each
  -- `ChordSlice` sequence already carries exporter fundamentals.
  let composerCadences = Map.map (buildCadencesPerPiece . Map.elems) activeComposers
  logCadenceStats composerCadences

  putStrLn "Computing Markov transitions per composer:"
  let composerTransitions = Map.map transitionProbabilitiesH composerCadences
  logTransitionStats composerTransitions

  let composerKeys = Map.keys activeComposers
      edges        = mergeComposerTransitions composerTransitions composerKeys

  pipe <- connectNeo4j
  -- Truncate the cadence subgraph each run so composer-specific MERGEs remain
  -- deterministic; APOC handles the heavy lifting in 5k batches.
  putStrLn "Clearing existing cadences from Neo4j (batched via APOC)..."
  Bolt.run pipe truncateCadenceGraph
  Bolt.run pipe initGraph
  putStrLn $ "Writing " ++ show (length edges) ++ " transitions into Neo4j..."
  Bolt.run pipe (writeCadenceEdges edges)
  putStrLn $ "Wrote " ++ show (length edges) ++ " transitions"

normalizeComposers :: YCACLData -> ComposerPieces
normalizeComposers dataset = foldl' insertComposer Map.empty (Map.toList dataset)
  where
    insertComposer acc (composer, pieces) =
      let key = slug composer
       in Map.insertWith (Map.unionWith (++)) key pieces acc

filterComposers :: ComposerPieces -> ComposerPieces
filterComposers dataset = Map.filterWithKey keep dataset
  where
    includes = if null composerInclude then const True else (`elem` composerInclude)
    keep key _ = includes key && key `notElem` composerExclude

-------------------------------------------------------------------------------
-- Local Markov functions using H.Cadence (replacing Harmonic.Analysis.Markov)
-- These will be migrated to Markov.hs in a later step
-------------------------------------------------------------------------------

type HTransitionCounts = Map HEdge Double
type HTotals = Map H.Cadence Double

transitionCountsH :: [H.Cadence] -> HTransitionCounts
transitionCountsH cadences =
  foldl' insertEdge Map.empty (zip cadences (drop 1 cadences))
  where
    insertEdge acc edge = Map.insertWith (+) edge 1 acc

transitionProbabilitiesH :: [H.Cadence] -> Map HEdge Double
transitionProbabilitiesH cadences =
  let counts = transitionCountsH cadences
      totals = buildTotals counts
   in Map.mapWithKey (normalise totals) counts
  where
    buildTotals :: HTransitionCounts -> HTotals
    buildTotals = foldl' accumulate Map.empty . Map.toList
      where
        accumulate acc ((from,_), weight) = Map.insertWith (+) from weight acc

    normalise :: HTotals -> HEdge -> Double -> Double
    normalise totals (from, _) weight =
      case Map.lookup from totals of
        Just total | total > 0 -> weight / total
        _                     -> 0

-------------------------------------------------------------------------------
-- Composer Transition Merging
-------------------------------------------------------------------------------

mergeComposerTransitions
  :: Map Text (Map HEdge Double)
  -> [Text]
  -> [(H.Cadence, H.Cadence, ComposerWeights)]
mergeComposerTransitions transitionMaps selected =
  let merged       = Map.foldlWithKey' accumulate Map.empty transitionMaps
      completeKeys = if null selected then Map.keys transitionMaps else selected
   in [ (from, to, ensureAll completeKeys weights)
      | ((from, to), weights) <- Map.toList merged
      , sum (Map.elems weights) > 0
      ]
  where
    accumulate acc composer edgeMap =
      foldl' (insertWeight composer) acc (Map.toList edgeMap)

    insertWeight composer acc (edge, weight) =
      Map.insertWith (Map.unionWith (+)) edge (Map.singleton composer weight) acc

    ensureAll composers weights = foldl' ensure weights composers
    ensure mp name = Map.insertWith (const id) name (0 :: Double) mp

-------------------------------------------------------------------------------
-- Logging Utilities
-------------------------------------------------------------------------------

logRawComposerStats :: ComposerPieces -> IO ()
logRawComposerStats composers =
  forM_ (Map.toList composers) $ \(name, pieces) ->
    let pieceCount = Map.size pieces
        chordCount = sum (map length (Map.elems pieces))
     in putStrLn $ "  - " ++ T.unpack name ++ ": " ++ show pieceCount ++ " pieces / " ++ show chordCount ++ " chord events"

logCadenceStats :: Map Text [H.Cadence] -> IO ()
logCadenceStats cadencesMap =
  forM_ (Map.toList cadencesMap) $ \(name, cadences) ->
    putStrLn $ "    cadences -> " ++ T.unpack name ++ ": " ++ show (length cadences)

logTransitionStats :: Map Text (Map HEdge Double) -> IO ()
logTransitionStats transitionMap =
  forM_ (Map.toList transitionMap) $ \(name, transitions) ->
    putStrLn $ "    transitions -> " ++ T.unpack name ++ ": " ++ show (Map.size transitions)

slug :: Text -> Text
slug = sanitize . T.toLower
  where
    sanitize = T.map replaceChar . T.filter validChar
    validChar c = isAlphaNum c || c == ' '
    replaceChar c
      | isAlphaNum c = c
      | otherwise    = '_'
```

### ./app/README.md

```
# app

`Main.hs` orchestrates the ingestion pipeline:

1. Loads `data/ycacl_sequences.csv` via `Harmonic.Ingestion.CSV`, producing a map of composers → pieces → `ChordSlice`s.
2. Logs coverage metrics so long exports can be monitored without inspecting Neo4j manually.
3. Builds duplicated cadence streams per composer (top triads replicated 3/2/1) by calling `Harmonic.Ingestion.Transform`.
4. Computes Markov transitions, merges them per `(:Cadence)-[:NEXT]->(:Cadence)` edge, and attaches per-composer weight maps.
5. Runs `truncateCadenceGraph` (APOC batched delete) followed by `initGraph` to keep the graph deterministic before writing the latest transitions.

When editing `Main.hs`, keep in mind that the file is the user-facing log surface—add descriptive `putStrLn`s any time new long-running work is introduced.
```

### ./ARCHITECTURE.md

```
# theHarmonicAlgorithm Architecture Guide

## 1. Introduction

### What is theHarmonicAlgorithm

theHarmonicAlgorithm is a Haskell library for generating harmonic progressions trained on the Yale Classical Archives Corpus (YCACL). It combines music theory, graph databases, and probabilistic selection to create musically coherent chord progressions.

The system generates progressions by:
1. Storing cadence transitions from the Bach chorales corpus in Neo4j
2. Applying harmonic constraints (overtones, key signatures, root motion)
3. Evaluating candidate cadences using dissonance and voice leading costs
4. Selecting next chords probabilistically using gamma-distribution sampling
5. Interfacing with TidalCycles for live music coding

### High-Level System Overview

```
                 R→E→T GENERATION PIPELINE

  ┌─────────────────────────────────────────────────────┐
  │                    Input State                       │
  │              (root, intervals, spelling)             │
  └─────────────────────┬───────────────────────────────┘
                        │
                        ▼
  ┌─────────────────────────────────────────────────────┐
  │                R: RULES LAYER                        │
  │  ┌────────────┬──────────────┬─────────────────┐   │
  │  │ Overtone   │ Key Filter   │  Root Filter    │   │
  │  │ Constraints│              │                 │   │
  │  └────────────┴──────────────┴─────────────────┘   │
  │         Define valid conceptual space                │
  └─────────────────────┬───────────────────────────────┘
                        │
                        ▼
  ┌─────────────────────────────────────────────────────┐
  │              E: EVALUATION LAYER                     │
  │  ┌────────────┬──────────────┬─────────────────┐   │
  │  │ Neo4j      │ Dissonance   │ Voice Leading  │   │
  │  │ Query      │ Scoring      │ Cost           │   │
  │  └────────────┴──────────────┴─────────────────┘   │
  │    Score quality of valid cadences                   │
  └─────────────────────┬───────────────────────────────┘
                        │
                        ▼
  ┌─────────────────────────────────────────────────────┐
  │              T: TRAVERSAL LAYER                      │
  │  ┌────────────┬──────────────┬─────────────────┐   │
  │  │Probabilistic│ Selection   │ Voice Leading  │   │
  │  │Sampling    │ Strategy    │ Optimization   │   │
  │  └────────────┴──────────────┴─────────────────┘   │
  │    Select next chord from evaluated candidates       │
  └─────────────────────┬───────────────────────────────┘
                        │
                        ▼
  ┌─────────────────────────────────────────────────────┐
  │                   Output State                       │
  │              (next chord in progression)             │
  └─────────────────────────────────────────────────────┘
```

### Target Audience

This document is for **developers** who want to:
- Understand the system architecture
- Extend functionality
- Fix bugs or optimize performance
- Contribute to the codebase

For usage instructions, see [README.md](README.md) and [live/USER_GUIDE.tidal](live/USER_GUIDE.tidal).

---

## 2. Creative Systems Framework (R→E→T)

### 2.1 Theoretical Foundation

The architecture implements Wiggins' **Creative Systems Framework** (Wiggins, G.A., 2006), which models creative generation as three components:

**Rules (R)**: Defines the universe of valid concepts
- Input: None (or constraint specifications)
- Output: Set of all valid possibilities
- Role: Constraint satisfaction, filtering
- Example: "All triads constructible from E-A-D-G overtones"

**Evaluation (E)**: Scores quality of valid concepts
- Input: Valid concept from R
- Output: Quality score (dissonance, voice leading cost, composer weight)
- Role: Preference ordering, ranking
- Example: "C major → F major scores 3.2 (dissonance) + 1.5 (voice leading)"

**Traversal (T)**: Navigates conceptual space
- Input: Evaluated candidates from E
- Output: Selected concept
- Role: Search strategy, selection
- Example: "Select next cadence using gamma sampling with entropy 0.5"

### Why R→E→T?

Traditional approaches mix constraints and preferences, making them brittle. The R→E→T separation allows:
- **Modularity**: Replace one component without affecting others
- **Clarity**: Explicit distinction between "valid" and "good"
- **Flexibility**: Same R with different T explores space differently

### 2.2 Framework Mapping to Modules

| Layer | Component | Modules | Responsibility |
|-------|-----------|---------|----------------|
| **Rules (R)** | Constraints | `Rules/Types/`, `Rules/Constraints/`, `Rules/Import/` | Define valid pitch-class sets, chord structures, filter specifications |
| **Evaluation (E)** | Quality Scoring | `Evaluation/Scoring/`, `Evaluation/Database/`, `Evaluation/Analysis/` | Score dissonance, voice leading costs, query composer weights |
| **Traversal (T)** | Selection | `Traversal/Probabilistic`, `Traversal/VoiceLeading` | Gamma sampling, voice leading optimization |
| **Framework** | Orchestration | `Framework/Builder` | Coordinate R→E→T pipeline |
| **Interface** | External Systems | `Interface/Tidal/` | TidalCycles integration |

### Dependency Flow

```
Framework.Builder
    │
    ├──▶ Rules.Types.Pitch         (R: foundational algebra)
    │      │
    ├──▶ Rules.Types.Harmony       (R: chord/cadence types)
    │      │
    ├──▶ Rules.Constraints.Filter  (R: harmonic constraints)
    │      │
    ├──▶ Rules.Constraints.Overtone(R: triad generation)
    │
    ├──▶ Evaluation.Scoring.Dissonance      (E: chord quality)
    │
    ├──▶ Evaluation.Scoring.VoiceLeading    (E: cost functions)
    │
    ├──▶ Evaluation.Database.Query          (E: graph queries)
    │
    └──▶ Traversal.Probabilistic            (T: selection)
```

---

## 3. Four-Layer Architecture

The codebase is organized into four vertical layers, inspired by the **Layer A (Memory) → Layer B (Brain) → Layer C (Hands) → Layer D (Voice)** paradigm:

```
    FOUR-LAYER VERTICAL ARCHITECTURE

┌────────────────────────────────────────────┐
│  Layer D: VOICE (Interface)                │
│                                            │
│  ┌──────────────────────────────────────┐ │
│  │  TidalCycles Bridge                  │ │
│  │  Pattern Lookup                      │ │
│  │  Voicing Strategies                  │ │
│  │  Arrangement Combinators             │ │
│  └──────────────────────────────────────┘ │
└────────────────┬───────────────────────────┘
                 │ depends on
                 ▼
┌────────────────────────────────────────────┐
│  Layer C: HANDS (Evaluation & Traversal)   │
│                                            │
│  ┌──────────────┐  ┌───────────────────┐  │
│  │  EVALUATION  │  │    TRAVERSAL      │  │
│  │  ────────────│  │   ─────────────── │  │
│  │  - Database  │  │  - Probabilistic  │  │
│  │    Queries   │  │    Sampling       │  │
│  │  - Dissonance│  │  - Selection      │  │
│  │    Scoring   │  │    Strategy       │  │
│  │  - Markov    │  │  - Voice Leading  │  │
│  │    Analysis  │  │    Optimization   │  │
│  └──────────────┘  └───────────────────┘  │
└────────────────┬───────────────────────────┘
                 │ depends on
                 ▼
┌────────────────────────────────────────────┐
│  Layer B: BRAIN (Types)                    │
│                                            │
│  ┌──────────────────────────────────────┐ │
│  │  Music Theory Primitives             │ │
│  │  ─────────────────────────           │ │
│  │  - Pitch-class Algebra (ℤ₁₂)        │ │
│  │  - Harmony Naming                    │ │
│  │  - Progression Structure             │ │
│  │  - Voice Leading Costs               │ │
│  └──────────────────────────────────────┘ │
└────────────────┬───────────────────────────┘
                 │ depends on
                 ▼
┌────────────────────────────────────────────┐
│  Layer A: MEMORY (Rules & Data)            │
│                                            │
│  ┌──────────────────────────────────────┐ │
│  │  Data Import Pipeline                │ │
│  │  ─────────────────────               │ │
│  │  - CSV Parsing (YCACL)               │ │
│  │  - Neo4j Graph Writes                │ │
│  │  - Constraint Specification          │ │
│  │  - Overtone Generation               │ │
│  └──────────────────────────────────────┘ │
└────────────────────────────────────────────┘

  ✓ Clean dependency flow (top → bottom)
  ✓ No circular dependencies
  ✓ Layer boundaries enforced by imports
```

### Layer A: Memory (Rules Component)

**Location**: `src/Harmonic/Rules/Import/`

**Purpose**: Ingests the Yale Classical Archives Corpus and populates Neo4j graph database

**Modules**:
- `Rules/Import/CSV.hs` - Parse YCACL CSV files
- `Rules/Import/Transform.hs` - Convert chords to cadences
- `Rules/Import/Types.hs` - ChordSlice and import types
- `Rules/Import/Graph.hs` - Neo4j schema writing

**Data Flow**:
```
Bach Chorales (CSV)
    → parseCSV
    → [ChordSlice]
    → buildCadences
    → [Cadence]
    → writeGraph (Neo4j)
    → NEXT relationships with weights
```

**Key Insight**: Cadences are stored in **zero-form** (relative intervals starting at 0), making the graph transposition-invariant. See Section 5.1 for details.

### Layer B: Brain (Music Theory Types)

**Location**: `src/Harmonic/Rules/Types/`

**Purpose**: Foundational music theory algebra and data structures

**Modules**:
- `Rules/Types/Pitch.hs` - ℤ₁₂ pitch-class algebra (src/Harmonic/Rules/Types/Pitch.hs:1)
- `Rules/Types/Harmony.hs` - Chord/cadence types and naming (src/Harmonic/Rules/Types/Harmony.hs:1)
- `Rules/Types/Progression.hs` - Progression monoid (src/Harmonic/Rules/Types/Progression.hs:1)

**Key Abstractions**:
- **PitchClass**: Newtype wrapping ℤ₁₂ with modular arithmetic
- **Chord**: Root + function name + intervals
- **Cadence**: Function name + movement + zero-form intervals
- **Progression**: Sequence of CadenceState wrapped in Monoid

**Design Principle**: Types enforce invariants. `PitchClass` cannot hold invalid values (≥12), enforced by smart constructors.

### Layer C: Hands (Evaluation & Traversal)

#### Evaluation (E Component)

**Location**: `src/Harmonic/Evaluation/`

**Modules**:
- `Evaluation/Scoring/Dissonance.hs` - Hindemith interval vectors (src/Harmonic/Evaluation/Scoring/Dissonance.hs:1)
- `Evaluation/Scoring/VoiceLeading.hs` - Voice leading cost functions (src/Harmonic/Evaluation/Scoring/VoiceLeading.hs:1)
- `Evaluation/Database/Query.hs` - Neo4j queries with composer weights (src/Harmonic/Evaluation/Database/Query.hs:1)
- `Evaluation/Analysis/Markov.hs` - Transition probability calculation (src/Harmonic/Evaluation/Analysis/Markov.hs:1)

**Scoring Metrics**:
- **Dissonance**: Hindemith intervalVector → sum of products with hindemithVector
- **Voice Leading**: Sum of voice movements + penalties (parallel fifths, large leaps)
- **Composer Weight**: Neo4j edge weight × composer blend factor

#### Traversal (T Component)

**Location**: `src/Harmonic/Traversal/`

**Modules**:
- `Traversal/Probabilistic.hs` - Gamma distribution sampling (src/Harmonic/Traversal/Probabilistic.hs:1)
- `Traversal/VoiceLeading.hs` - Dynamic programming optimization (src/Harmonic/Evaluation/Scoring/VoiceLeading.hs:155-200)

**Selection Strategy**:
1. Query Neo4j for candidates matching current cadence
2. Filter by harmonic context (R constraints)
3. Score by dissonance + voice leading (E metrics)
4. Sample using gamma distribution (T strategy)

**Entropy Parameter**: Controls exploration vs exploitation
- Low entropy (0.2): Exploit - select high-weight cadences
- High entropy (0.8): Explore - select from deeper in the list

### Layer D: Voice (TidalCycles Interface)

**Location**: `src/Harmonic/Interface/Tidal/`

**Purpose**: Bridge between harmonic engine and TidalCycles live coding

**Modules**:
- `Interface/Tidal/Bridge.hs` - Pattern-based lookup with modulo wrap (src/Harmonic/Interface/Tidal/Bridge.hs:1)
- `Interface/Tidal/Arranger.hs` - Voicing strategies (flow, root, lite, etc.)
- `Interface/Tidal/Instruments.hs` - Launcher definitions (juno, moog, etc.)
- `Interface/Tidal/Utils.hs` - Utility functions

**Key Concept**: **Modulo Wrap**
- Progressions are finite (e.g., 16 chords)
- TidalCycles patterns are infinite
- `lookupChord prog idx` wraps: `chords !! (idx mod length)`
- Enables `run 4` on 16-chord progression → loops first 4

---

## 4. Module Structure

### Directory Organization

```
src/Harmonic/
│
├── Lib.hs                    [Main re-export, public API]
├── Config.hs                 [Neo4j configuration]
│
├── Framework/                [R→E→T Orchestration]
│   └── Builder.hs            [Generation engine, coordinates R→E→T]
│
├── Rules/                    [R Component + Layer A (Memory)]
│   ├── Types/                [Foundational music theory types]
│   │   ├── Pitch.hs          [ℤ₁₂ pitch-class algebra]
│   │   ├── Harmony.hs        [Chord/cadence types and naming]
│   │   └── Progression.hs    [Progression monoid]
│   ├── Constraints/          [Filtering and validity rules]
│   │   ├── Filter.hs         [Harmonic context filtering]
│   │   └── Overtone.hs       [Triad generation from overtones]
│   └── Import/               [Data ingestion pipeline]
│       ├── CSV.hs            [YCACL CSV parsing]
│       ├── Transform.hs      [ChordSlice → Cadence]
│       ├── Types.hs          [Import data types]
│       └── Graph.hs          [Neo4j schema writes]
│
├── Evaluation/               [E Component + Layer C (Hands)]
│   ├── Scoring/              [Quality assessment]
│   │   ├── Dissonance.hs     [Hindemith interval vectors]
│   │   └── VoiceLeading.hs   [Voice leading cost functions]
│   ├── Database/             [Graph queries and ranking]
│   │   └── Query.hs          [Neo4j queries with composer weights]
│   └── Analysis/             [Statistical evaluation]
│       └── Markov.hs         [Transition probability calculation]
│
├── Traversal/                [T Component + Layer C (Hands)]
│   └── Probabilistic.hs      [Gamma distribution sampling]
│
└── Interface/                [Layer D (Voice) - TidalCycles]
    └── Tidal/                [TidalCycles-specific bridge]
        ├── Bridge.hs         [Pattern lookup and modulo wrap]
        ├── Arranger.hs       [Voicing strategies (flow, root, lite)]
        ├── Instruments.hs    [Launcher definitions]
        └── Utils.hs          [Utility functions]
```

### Module Dependency Graph

```
MODULE DEPENDENCY FLOW (simplified)

Harmonic.Lib (re-exports)
    │
    └──▶ Framework.Builder ◀──────────────┐
            │                              │
            ├──▶ Rules.Types.Pitch         │
            │      │                       │
            ├──▶ Rules.Types.Harmony       │
            │      │                       │
            ├──▶ Rules.Constraints.Filter  │
            │      │                       │
            ├──▶ Rules.Constraints.Overtone│
            │                              │
            ├──▶ Evaluation.Scoring.Dissonance
            │                              │
            ├──▶ Evaluation.Database.Query │
            │                              │
            ├──▶ Traversal.Probabilistic   │
            │                              │
            └──▶ Evaluation.Scoring.VoiceLeading
                    │
                    └──▶ Traversal optimization

Interface.Tidal.Bridge
    │
    ├──▶ Rules.Types.Progression
    │
    └──▶ Interface.Tidal.Arranger
            │
            └──▶ Evaluation.Scoring.VoiceLeading
```

### Layer Boundary Enforcement

Enforced through Haskell imports:
- Layer B (Types) modules **cannot** import from C or D
- Layer C (Evaluation/Traversal) may import from B but **not** D
- Layer D (Interface) may import from B and C

**Rationale**: Prevents circular dependencies, enforces unidirectional data flow.

---

## 5. Core Concepts

### 5.1 Zero-Form Invariant

**Definition**: All cadences are stored as **relative intervals** starting at pitch-class 0.

```
ZERO-FORM INVARIANT: Relative vs. Absolute

ABSOLUTE (Chord):                  RELATIVE (Cadence):
Root + Intervals                   Movement + Intervals (zero-form)

C major:  C + [0,4,7]              Up 0 semitones + [P 0, P 4, P 7]
F major:  F + [0,4,7]              Up 5 semitones + [P 0, P 4, P 7]
G major:  G + [0,4,7]              Up 2 semitones + [P 0, P 4, P 7]
                                           ↑
                                   Same relative structure!

WHY?
  1. Transposition-invariant analysis
  2. Dataset not biased toward common keys
  3. Smaller transition matrix (12× fewer states)
  4. Emphasizes cadence MOVEMENT not chord identity

IMPLEMENTATION:
  - Neo4j stores: Cadence nodes with [P 0, ...] intervals
  - Runtime: Convert to absolute ChordState for playback
  - Builder: Maintains absolute root, queries relative cadences
```

**Example Code** (src/Harmonic/Rules/Types/Harmony.hs:154-167):
```haskell
-- Convert absolute Chord pair to relative Cadence
toCadence :: (Chord, Chord) -> Cadence
toCadence (from, to) =
  let fromRoot = pitchClass (chordRoot from)
      toRoot = pitchClass (chordRoot to)
      mvmt = toMovement fromRoot toRoot
      -- Zero-form: shift intervals so first = P 0
      zeroPcs = case toIntervals of
        [] -> []
        (p:ps) -> P 0 : map (subtract p) ps
   in Cadence (chordFunc to) mvmt zeroPcs
```

### 5.2 Builder Pipeline

The `Framework.Builder` module orchestrates the R→E→T pipeline (src/Harmonic/Framework/Builder.hs:1):

```
GENERATION FLOW (R→E→T)

Input: CadenceState, length, composer, entropy, HarmonicContext
    │
    ▼
┌─────────────────────────────────────┐
│ FOR each step in progression:      │
│                                     │
│  1. RULES (R): Filter candidates   │
│     - Query Neo4j for NEXT edges   │
│     - Apply overtone filter        │
│     - Apply key filter             │
│     - Apply root filter            │
│                                     │
│  2. EVALUATION (E): Score quality  │
│     - Dissonance score             │
│     - Voice leading cost           │
│     - Composer weight blend        │
│                                     │
│  3. TRAVERSAL (T): Select next     │
│     - Gamma sampling with entropy  │
│     - Update CadenceState          │
│     - Append to progression        │
│                                     │
└─────────────────────────────────────┘
    │
    ▼
Output: Progression (Seq CadenceState)
```

**Verbosity Levels**:
- **Silent** (`genSilent`): No diagnostics
- **Standard** (`genStandard`): Per-step summaries
- **Verbose** (`genVerbose`): Full traces (root motion, functionality, voice leading)

**State Threading**: Builder maintains `CadenceState` through generation:
```haskell
data CadenceState = CadenceState
  { csRoot      :: NoteName      -- Absolute root (e.g., C, F#, Bb)
  , csFunc      :: String        -- Function name ("maj", "min7", etc.)
  , csIntervals :: [PitchClass]  -- Absolute intervals [0,4,7]
  , csSpelling  :: EnharmonicSpelling  -- FlatSpelling or SharpSpelling
  }
```

### 5.3 HarmonicContext

The `HarmonicContext` type encodes the three-filter system (src/Harmonic/Framework/Builder.hs:68-72):

```haskell
data HarmonicContext = HarmonicContext
  { overtoneFilter :: String  -- Pitch-set constraint ("E A D G", "C", "*")
  , keyFilter      :: String  -- Key signature ("1#", "2b", "*")
  , rootFilter     :: String  -- Root motion constraint ("1#", "E G", "*")
  }
```

**Filter Interaction**:
1. **Overtone Filter**: Restricts chord pitch-classes to overtone series
   - `"E A D G"` → Only pitches in {E,A,D,G,B,F#,C#,G#,D#,A#} (combined overtones)
   - `"C"` → Only pitches in {C,E,G,Bb} (C overtone series)
   - Prime notation `"C'"` → Exact pitch-class (no overtones)

2. **Key Filter**: Restricts to diatonic collection
   - `"1#"` → G major scale {G,A,B,C,D,E,F#}
   - `"2b"` → Bb major scale {Bb,C,D,Eb,F,G,A}
   - Named keys `"D"` → D major scale

3. **Root Filter**: Restricts root motion
   - `"E G"` → Only cadences with E or G as root
   - `"1#"` → Only roots in G major scale

**Wildcard**: `"*"` matches all (no filtering)

**Example Usage** (from live/USER_GUIDE.tidal):
```haskell
-- G major tonality with G major roots
ctx1 <- harmonicContext "*" "1#" "1#"

-- D major roots only, any pitch content
ctx2 <- harmonicContext "*" "*" "##"

-- Specific overtones, any key/roots
ctx3 <- harmonicContext "D A D F A Ab" "*" "*"
```

---

## 6. Database Schema

### 6.1 Neo4j Structure

**Connection**: `bolt://localhost:7687` (credentials: neo4j/password)

**Node Type**:
```cypher
(:Cadence {
  func: String,        -- Function name ("maj", "min7", etc.)
  movement: String,    -- Movement type ("Asc P 5", "Desc P 4", "Unison")
  intervals: [Int]     -- Zero-form intervals [0, 4, 7]
})
```

**Relationship Types**:
```cypher
(:Cadence)-[:NEXT {weight: Float, composer: String}]->(:Cadence)
(:Cadence)-[:COMPOSER {name: String}]->(:Cadence)
```

**Weight Calculation** (src/Harmonic/Evaluation/Analysis/Markov.hs:27-42):
```haskell
-- Transition probability P(to | from) = count(from → to) / count(from → *)
transitionProbabilities :: [Cadence] -> Map Edge Double
transitionProbabilities cadences =
  let counts = transitionCounts cadences  -- Map (from, to) → count
      totals = buildTotals counts         -- Map from → total_count
   in Map.mapWithKey (normalise totals) counts
```

### 6.2 YCACL Corpus

**Dataset**: Yale Classical Archives Corpus of Bach chorales
- **Size**: 60 chorales, ~5000 chords
- **Format**: CSV with columns `[pitch1, pitch2, pitch3, pitch4, ...]`
- **Preprocessing** (src/Harmonic/Rules/Import/Transform.hs:21-63):
  1. Extract fundamental (lowest pitch-class)
  2. Generate triad interpretations (top 3 by consonance)
  3. Duplicate high-scoring triads (3×, 2×, 1×) for weight
  4. Build cadence transitions (cross-multiply adjacent slices)

**Statistical Properties**:
- **Most common cadence**: `V → I` (dominant to tonic)
- **Most common root motion**: Descending fifth (P 5)
- **Average dissonance**: 6.8 (major/minor triads score 6.0)

---

## 7. TidalCycles Integration

### 7.1 Pattern Bridge

The `Interface.Tidal.Bridge` module provides pattern-based lookup (src/Harmonic/Interface/Tidal/Bridge.hs:1):

**Key Function**:
```haskell
lookupChord :: Progression -> Int -> Chord
lookupChord prog idx =
  let len = progLength prog
      chords = progChords prog
      wrappedIdx = idx `mod` len
   in chords !! wrappedIdx
```

**Modulo Wrap Behavior**:
- `lookupChord prog 0` → first chord
- `lookupChord prog 16` → chord at `(16 mod len)`
- Enables infinite cycling: `run 4` on 16-bar progression loops first 4

**Pattern Syntax** (TidalCycles):
```haskell
-- Simple index pattern
d1 $ note (harmony prog "0 1 2 3") # s "superpiano"

-- Euclidean rhythm
d1 $ note (harmony prog (run 8)) # s "superpiano"

-- Nested patterns
d1 $ note (harmony prog "<0 [1 2] 3>") # s "superpiano"
```

### 7.2 Voicing Strategies

The `Interface.Tidal.Arranger` module provides voicing functions:

**Flow Voicing** (voice-led, cyclic DP smoothing):
```haskell
flow :: Progression -> [[Int]]
flow prog =
  let states = toList (unProgression prog)
      chords = map (toTriad . fromCadenceState) states
      voicings = solveFlow chords  -- Cyclic DP optimization
   in map chordPitches voicings
```

**Root Voicing** (root position):
```haskell
root :: Progression -> [[Int]]
root prog = map rootPosition (progChords prog)
```

**Lite Voicing** (literal intervals, no voice leading):
```haskell
lite :: Progression -> [[Int]]
lite prog = literalVoicing prog
```

**Bass Extraction** (single pitch):
```haskell
bass :: Progression -> [[Int]]
bass prog = map (